[
  {
    "id": 1,
    "question": "List all sector names and their IDs",
    "ground_truth_sql": "SELECT sector_id, sector_name FROM sectors ORDER BY sector_id",
    "difficulty": "simple",
    "category": "select_all",
    "reasoning": "To list all sector names and their IDs, follow these steps:\n\n1. **Identify the required data**: We need two pieces of information: the sector names and their IDs. \n\n2. **Determine the relevant tables and columns**: Typically, sector information is stored in a table named `sectors` or a similar name. Assuming this, we need to access the `id` and `name` columns of this table.\n\n3. **Define the SQL query structure**: We will use a `SELECT` statement to retrieve the required data. The basic structure will be:\n   ```sql\nSELECT \n    id,\n    name\nFROM \n    sectors;\n```\n\n4. **Apply no additional filters or conditions**: Since we're listing all sectors, no filters or conditions are required. The above query will return all sector names and their IDs.\n\n5. **Run the query**: Execute the constructed SQL query to obtain the desired results.\n\nNote: The table and column names used here are assumed based on common database schema. If your actual schema is different, adapt the query accordingly.",
    "augmentation_type": "cot",
    "original_question": "List all sector names and their IDs"
  },
  {
    "id": 2,
    "question": "Find all countries with 'United' in their name",
    "ground_truth_sql": "SELECT country_name FROM countries WHERE country_name LIKE '%United%'",
    "difficulty": "simple",
    "category": "pattern_match",
    "reasoning": "Here's a step-by-step breakdown of how to construct the SQL query to answer the question:\n\n**1. Identify the necessary data and tables**\n\n- We need a list of countries with 'United' in their name.\n- The most relevant data is likely stored in a table that contains country information, such as a 'countries' table.\n- We will assume that this table has columns for country names, such as 'country_name' or 'name'.\n\n**2. Identify the specific columns needed**\n\n- We need the country names that contain 'United'.\n- Therefore, we will select the 'country_name' column (or the equivalent) from the 'countries' table.\n\n**3. Apply filters or conditions**\n\n- We want to find countries with 'United' in their name.\n- This can be achieved by using the LIKE operator with a wildcard '%' to match any characters before and after 'United'.\n- The filter condition would be: `country_name LIKE '%United%'`\n\n**4. Write the query**\n\n- The query will select the country names that match the filter condition from the 'countries' table.\n\nHere's the resulting SQL query:\n\n```sql\nSELECT country_name\nFROM countries\nWHERE country_name LIKE '%United%';\n```\n\nThis query will return a list of country names that contain the word 'United'.",
    "augmentation_type": "cot",
    "original_question": "Find all countries with 'United' in their name"
  },
  {
    "id": 3,
    "question": "How many GFS indicators are there?",
    "ground_truth_sql": "SELECT COUNT(*) AS gfs_indicator_count FROM indicators WHERE source = 'GFS'",
    "difficulty": "simple",
    "category": "count_filtered",
    "reasoning": "Here's the step-by-step process to construct the SQL query:\n\n1. **Determine the data needed**: The question asks for the total number of GFS indicators, so we need a count of GFS indicators.\n\n2. **Identify the relevant tables and columns**: To count GFS indicators, we likely need a table that stores indicator data, possibly with a column that specifically identifies GFS indicators. Let's assume the table is named `indicators` and has a column named `indicator_type` that stores the type of indicator (e.g., 'GFS').\n\n3. **Apply filters or conditions**: Since the question doesn't specify any other criteria, we can filter the `indicator_type` column for 'GFS'. This will ensure we only count GFS indicators.\n\n4. **Determine the aggregation or calculation needed**: We need to count the number of rows where `indicator_type` is 'GFS'. This can be achieved using the `COUNT` aggregation function.\n\n5. **Construct the SQL query**:\n    - `SELECT COUNT(*)` to count the number of rows\n    - `FROM indicators` to specify the table we're querying\n    - `WHERE indicator_type = 'GFS'` to filter the results to only GFS indicators\n\nThe resulting SQL query would be:\n```sql\nSELECT COUNT(*) \nFROM indicators \nWHERE indicator_type = 'GFS';\n```\nThis query will return the total number of GFS indicators in the `indicators` table.",
    "augmentation_type": "cot",
    "original_question": "How many GFS indicators are there?"
  },
  {
    "id": 4,
    "question": "List all GFS indicator names that contain 'Revenue'",
    "ground_truth_sql": "SELECT DISTINCT indicator_name FROM indicators WHERE source = 'GFS' AND indicator_name LIKE '%Revenue%'",
    "difficulty": "simple",
    "category": "pattern_match",
    "reasoning": "To answer the question \"List all GFS indicator names that contain 'Revenue'\", we'll follow these steps:\n\n1. **Determine the data needed**: We need the indicator names that contain the word 'Revenue'. This means we'll focus on the textual data associated with the indicators.\n\n2. **Identify the relevant tables and columns**:\n   - We should start by looking at the table that stores indicator information. \n   - Since we're interested in the indicator names, we'll need a column that stores these names.\n\n3. **Apply the necessary filter or condition**: We need to filter the indicator names to include only those that contain the word 'Revenue'. This can be achieved using a `LIKE` operator in SQL, along with a wildcard character (`%`) to match any characters before or after 'Revenue'.\n\n4. **Use a `SELECT` statement to retrieve the required data**: We'll use a `SELECT` statement to retrieve the indicator names. Since we're not performing any aggregations or calculations, the `SELECT` statement will be straightforward.\n\n5. **Add a filter to retrieve only GFS indicator names**: To ensure we only retrieve GFS indicator names, we need to add a filter to our `WHERE` clause.\n\n6. **Write the complete SQL query**:\n   - `SELECT` the column that stores the indicator names.\n   - `FROM` the table that stores the indicator information.\n   - `WHERE` the indicator name contains the word 'Revenue' and the indicator type is 'GFS'.\n\nHere's the complete SQL query:\n```sql\nSELECT indicator_name\nFROM indicators\nWHERE indicator_name LIKE '%Revenue%' AND indicator_type = 'GFS';\n```\nThis query will return all GFS indicator names that contain the word 'Revenue'.",
    "augmentation_type": "cot",
    "original_question": "List all GFS indicator names that contain 'Revenue'"
  },
  {
    "id": 5,
    "question": "List countries whose names start with 'A'",
    "ground_truth_sql": "SELECT country_name FROM countries WHERE country_name LIKE 'A%' ORDER BY country_name",
    "difficulty": "simple",
    "category": "pattern_match",
    "reasoning": "**Step 1: Identify the data needed**\nTo answer the question, we need a table that contains a list of countries with their corresponding names.\n\n**Step 2: Determine which tables/columns to use**\nWe will likely use a table named `countries` that has a column named `name` or `country_name` to store country names.\n\n**Step 3: Apply filters or conditions**\nWe want to list countries whose names start with 'A'. To do this, we'll use a condition in the `WHERE` clause to filter the results.\n\n**Step 4: Construct the SQL query**\nHere is the step-by-step construction of the SQL query:\n\n1. Start with the basic `SELECT` statement to retrieve the country names.\n2. Use the `WHERE` clause to apply the condition that the country name starts with 'A'. We can use the `LIKE` operator with a wildcard character `%` to match any characters after 'A'.\n3. Specify the table name and the column name to use.\n\n**SQL Query:**\n```sql\nSELECT name\nFROM countries\nWHERE name LIKE 'A%';\n```\nThis query will return the names of countries whose names start with 'A'.",
    "augmentation_type": "cot",
    "original_question": "List countries whose names start with 'A'"
  },
  {
    "id": 6,
    "question": "How many GEM observations are in the database?",
    "ground_truth_sql": "SELECT COUNT(*) AS observation_count FROM gem_observations",
    "difficulty": "simple",
    "category": "count",
    "reasoning": "**Step-by-Step Guide to Constructing the SQL Query**\n\n**1. Identify the Data Needed:**\nWe need to find the count of GEM observations, which implies we need a column that indicates whether an observation is a GEM or not.\n\n**2. Choose the Relevant Tables and Columns:**\nTo determine the count of GEM observations, we'll likely need to join multiple tables. We'll assume the following tables and columns are available:\n- `observations`: contains all observations with a column `is_gem` indicating whether it's a GEM observation.\n- `metadata`: contains metadata about each observation.\n\n**3. Apply Filters or Conditions:**\nWe don't need any specific filters or conditions to count all GEM observations, so our filter will be empty.\n\n**4. Determine the Aggregation or Calculation:**\nSince we want to find the total count of GEM observations, we'll use the `COUNT` aggregation function.\n\n**5. Construct the SQL Query:**\n```sql\nSELECT COUNT(*)\nFROM observations\nWHERE is_gem = 1;\n```\nThis query will count the number of rows in the `observations` table where the `is_gem` column is 1, effectively giving us the total count of GEM observations.\n\n**6. Consider Joining Additional Tables (if necessary):**\nIf we need data from other tables to determine what constitutes a GEM observation, we'll need to join those tables in our query. However, based on the information provided, we can answer the question with the above query.",
    "augmentation_type": "cot",
    "original_question": "How many GEM observations are in the database?"
  },
  {
    "id": 7,
    "question": "How many GFS observations are in the database?",
    "ground_truth_sql": "SELECT COUNT(*) AS observation_count FROM gfs_observations",
    "difficulty": "simple",
    "category": "count",
    "reasoning": "Here's the step-by-step breakdown to construct the SQL query:\n\n**1. What data is needed:**\nTo answer the question \"How many GFS observations are in the database?\", we need to know the total count of rows in the table that stores GFS observations.\n\n**2. Which tables/columns to use:**\nGiven that GFS observations are likely stored in a table related to weather or climate data, we'll assume a table name like `gfs_observations` or `weather_data`. We'll use the `id` or `observation_id` column to identify each observation and the `type` or `observation_type` column to filter for GFS observations.\n\n**3. What filters or conditions to apply:**\nTo count only GFS observations, we'll apply a filter condition to the `type` or `observation_type` column to check for 'GFS' or 'Global Forecast System'.\n\n**4. What aggregations or calculations are needed:**\nSince we're only counting the number of GFS observations, we'll use the `COUNT()` aggregation function to calculate the total count of rows that match the filter condition.\n\nHere's the SQL query:\n```sql\nSELECT COUNT(id) AS num_gfs_observations\nFROM gfs_observations\nWHERE type = 'GFS';\n```\nThis query:\n\n* Selects the `id` column to count the number of rows.\n* Uses the `COUNT()` aggregation function to calculate the total count.\n* Filters the results to only include rows where the `type` column is 'GFS'.\n* Assigns the alias `num_gfs_observations` to the count result for clarity.\n\nNote: If the table name or column names are different, simply replace them in the query accordingly.",
    "augmentation_type": "cot",
    "original_question": "How many GFS observations are in the database?"
  },
  {
    "id": 8,
    "question": "List all distinct GEM indicator names",
    "ground_truth_sql": "SELECT DISTINCT indicator_name FROM indicators WHERE source = 'GEM' ORDER BY indicator_name",
    "difficulty": "simple",
    "category": "distinct_filtered",
    "reasoning": "**Step-by-Step SQL Query Construction**\n\n**Question:** List all distinct GEM (Global Entrepreneurship and Competitiveness) indicator names\n\n**1. Identify the data needed:**\nTo answer this question, we need data from a table that contains information about GEM indicators, including their names.\n\n**2. Determine the tables and columns to use:**\nAssuming we have a table named `gem_indicators` that contains the following columns:\n- `id`: unique identifier for each indicator\n- `name`: name of the GEM indicator\n- `description`: description of the GEM indicator (not necessary for this query)\n\nWe will use the `name` column from the `gem_indicators` table.\n\n**3. Apply filters or conditions:**\nNo filters or conditions are necessary for this query. We simply want to retrieve all distinct GEM indicator names.\n\n**4. Determine the aggregation or calculation:**\nSince we want to retrieve all distinct GEM indicator names, we can use the `DISTINCT` keyword to ensure that each name is only listed once.\n\n**SQL Query:**\n```sql\nSELECT DISTINCT name\nFROM gem_indicators;\n```\nThis query will return a list of all distinct GEM indicator names from the `gem_indicators` table.",
    "augmentation_type": "cot",
    "original_question": "List all distinct GEM indicator names"
  },
  {
    "id": 9,
    "question": "How many GEM indicators are there?",
    "ground_truth_sql": "SELECT COUNT(*) AS gem_indicator_count FROM indicators WHERE source = 'GEM'",
    "difficulty": "simple",
    "category": "count_filtered",
    "reasoning": "Here's a step-by-step breakdown of how to construct the SQL query to answer the question:\n\n1. **What data is needed**: The question asks for the count of GEM indicators, which implies we only need to know the existence of GEM indicators in the database.\n\n2. **Which tables/columns to use**: Since we're looking for GEM indicators, we'll likely need a table that stores information about indicators. Let's assume the table is named `indicators` and has a column named `indicator_type` that stores the type of indicator (e.g., 'GEM', 'Other'). We'll also need a column to count the number of indicators.\n\n3. **What filters or conditions to apply**: Since we're only interested in GEM indicators, we'll apply a filter to the `indicator_type` column to select only rows where `indicator_type` equals 'GEM'.\n\n4. **What aggregations or calculations are needed**: We need to count the number of GEM indicators. This means we'll use the `COUNT()` aggregation function on the table, filtering for `indicator_type` = 'GEM'.\n\nHere's the SQL query:\n\n```sql\nSELECT COUNT(*) AS num_gem_indicators\nFROM indicators\nWHERE indicator_type = 'GEM';\n```\n\nThis query will return the count of GEM indicators in the `indicators` table.",
    "augmentation_type": "cot",
    "original_question": "How many GEM indicators are there?"
  },
  {
    "id": 10,
    "question": "What is the earliest year in the GFS observations?",
    "ground_truth_sql": "SELECT MIN(year) AS earliest_year FROM gfs_observations",
    "difficulty": "simple",
    "category": "min",
    "reasoning": "Here's the step-by-step process to construct the SQL query:\n\n**Step 1: Determine the required data and tables**\n\n- The question asks for the earliest year in the GFS (General Forecast System) observations.\n- We likely need a table containing GFS observation data.\n- Let's call this table \"gfs_observations\".\n\n**Step 2: Identify the relevant columns**\n\n- To find the earliest year, we need a column containing the year information.\n- This column is likely \"year\" or a similar name.\n- Let's assume the column name is \"year\".\n\n**Step 3: Apply filters or conditions**\n\n- Since we're looking for the earliest year, we don't need to filter the data based on other conditions.\n- We can simply select the minimum year value from the \"year\" column.\n\n**Step 4: Determine the necessary aggregation or calculation**\n\n- We don't need any aggregations or calculations since we're simply selecting the minimum year value.\n- A basic SELECT statement with a MIN function will suffice.\n\n**Step 5: Write the SQL query**\n\n- Based on the previous steps, the SQL query would be:\n```sql\nSELECT MIN(year) AS earliest_year\nFROM gfs_observations;\n```\nThis query will return the earliest year in the GFS observations.",
    "augmentation_type": "cot",
    "original_question": "What is the earliest year in the GFS observations?"
  },
  {
    "id": 11,
    "question": "How many different indicators are there in total?",
    "ground_truth_sql": "SELECT COUNT(*) AS indicator_count FROM indicators",
    "difficulty": "simple",
    "category": "count",
    "reasoning": "**Step-by-Step SQL Query Construction**\n\n**Question:** How many different indicators are there in total?\n\n**1. What data is needed:**\nTo answer this question, we need to count the number of unique indicators. This implies we need a column that stores the indicator values.\n\n**2. Which tables/columns to use:**\nBased on the requirement, we assume there is a table called `indicators` with a column named `indicator_value`. If the schema is different, please provide the table structure for further assistance.\n\n**3. What filters or conditions to apply:**\nSince we are interested in counting all unique indicators, we do not need to apply any filters or conditions. We want to include all records from the `indicators` table.\n\n**4. What aggregations or calculations are needed:**\nTo get the total count of unique indicators, we will use the `COUNT(DISTINCT)` aggregation function. This function counts the number of unique values in a given column.\n\n**SQL Query:**\n```sql\nSELECT COUNT(DISTINCT indicator_value) AS total_indicators\nFROM indicators;\n```\nThis query will return the total count of unique indicators, which is the answer to the question.\n\n**Note:** If you want to store the result in a variable or assign it to a specific column, you can modify the query accordingly. For example, to store the result in a variable named `total_indicators_count`, you can use:\n```sql\nSET @total_indicators_count = (SELECT COUNT(DISTINCT indicator_value) FROM indicators);\n```",
    "augmentation_type": "cot",
    "original_question": "How many different indicators are there in total?"
  },
  {
    "id": 12,
    "question": "How many distinct countries have GEM data?",
    "ground_truth_sql": "SELECT COUNT(DISTINCT country_id) AS country_count FROM gem_observations",
    "difficulty": "simple",
    "category": "count_distinct",
    "reasoning": "**Step-by-Step Guide to Constructing the SQL Query**\n\n1. **Determine the data needed**:\n   - The query requires information about countries with GEM (Global Entrepreneurship Monitor) data.\n\n2. **Identify the relevant tables and columns**:\n   - Typically, GEM data is stored in a database with a schema that includes a table for country information.\n   - Let's assume the relevant tables are:\n     - `countries` (with columns `country_id`, `country_name`, etc.)\n     - `gem_data` (with columns `gem_id`, `country_id`, `gem_status`, etc.)\n   - We will use the `countries` table to retrieve country information and the `gem_data` table to filter for GEM data.\n\n3. **Apply filters or conditions**:\n   - To answer the question, we need to filter the `gem_data` table for records with valid GEM status.\n   - This will likely involve a condition on the `gem_status` column, such as `gem_status = 'active'` or `gem_status = 'published'`.\n\n4. **Aggregate or calculate the result**:\n   - Since we want to know the number of distinct countries with GEM data, we will use an aggregate function, specifically `COUNT(DISTINCT)`, to count the unique country IDs.\n\n5. **Write the SQL query**:\n   - Combining the above steps, the query might look like this:\n     ```sql\nSELECT COUNT(DISTINCT c.country_id)\nFROM countries c\nJOIN gem_data g ON c.country_id = g.country_id\nWHERE g.gem_status = 'active';\n```\n\nThis query joins the `countries` and `gem_data` tables on the `country_id` column and filters for records with an active GEM status. The `COUNT(DISTINCT)` function then returns the number of distinct country IDs, which is the number of distinct countries with GEM data.",
    "augmentation_type": "cot",
    "original_question": "How many distinct countries have GEM data?"
  },
  {
    "id": 13,
    "question": "Find the minimum value in GEM observations (excluding nulls)",
    "ground_truth_sql": "SELECT MIN(value) AS min_value FROM gem_observations WHERE value IS NOT NULL",
    "difficulty": "simple",
    "category": "min",
    "reasoning": "Here's the step-by-step process to construct the SQL query:\n\n**1. Identify the data needed and tables/columns to use:**\n- We need to find the minimum value in GEM observations.\n- We assume there is a table named 'gem_observations' containing the GEM data.\n- The table has a column for the GEM observation values, which we will denote as 'observation_value'.\n\n**2. Specify the structure of the table:**\nFor the sake of this query, the table structure is as follows:\n```sql\nCREATE TABLE gem_observations (\n    id INT PRIMARY KEY,\n    observation_value FLOAT NOT NULL,\n    -- other columns...\n);\n```\n**3. Apply filters or conditions:**\n- We need to exclude null values from the query.\n- We will apply a filter to exclude rows where 'observation_value' is NULL.\n\n**4. Determine the aggregation or calculation:**\n- We need to find the minimum value of 'observation_value' excluding nulls.\n\n**5. Construct the SQL query:**\n```sql\nSELECT MIN(observation_value)\nFROM gem_observations\nWHERE observation_value IS NOT NULL;\n```\nThis query will return the minimum 'observation_value' excluding nulls from the 'gem_observations' table.",
    "augmentation_type": "cot",
    "original_question": "Find the minimum value in GEM observations (excluding nulls)"
  },
  {
    "id": 14,
    "question": "How many observations have 'Percent of GDP' as the transformation?",
    "ground_truth_sql": "SELECT COUNT(*) AS count FROM gfs_observations WHERE transformation = 'Percent of GDP'",
    "difficulty": "simple",
    "category": "count_filtered",
    "reasoning": "To answer the question \"How many observations have 'Percent of GDP' as the transformation?\", we'll break it down into logical steps.\n\n**Step 1: Identify the data needed**\nWe need to identify the table(s) that contain the information about transformations and their corresponding counts.\n\n**Step 2: Determine the relevant tables and columns**\nWe'll assume that we have a table named \"transformations\" with columns:\n- \"id\" (primary key)\n- \"name\" (transformation name)\n- \"description\"\n\nOur goal is to find the count of rows where the \"name\" column equals 'Percent of GDP'.\n\n**Step 3: Apply filters or conditions**\nTo filter the rows that match the condition, we'll use the following WHERE clause:\n- \"WHERE name = 'Percent of GDP'\"\n\n**Step 4: Determine the necessary aggregation or calculation**\nSince we're looking for a count of rows, we can use the COUNT() function without any aggregate arguments.\n\n**Step 5: Construct the SQL query**\nBased on the previous steps, our SQL query would look like this:\n\n```sql\nSELECT COUNT(*) \nFROM transformations \nWHERE name = 'Percent of GDP';\n```\n\nThis query will return the number of rows where the \"name\" column equals 'Percent of GDP'.\n\n**Additional considerations**\n- We should ensure that the table \"transformations\" is properly indexed to improve query performance.\n- If there are multiple tables involved, we may need to adjust the join conditions accordingly.\n- Depending on the specific data and requirements, additional filtering conditions or aggregations might be necessary.",
    "augmentation_type": "cot",
    "original_question": "How many observations have 'Percent of GDP' as the transformation?"
  },
  {
    "id": 15,
    "question": "What is the latest year in the GEM observations?",
    "ground_truth_sql": "SELECT MAX(year) AS latest_year FROM gem_observations",
    "difficulty": "simple",
    "category": "max",
    "reasoning": "Here's a step-by-step breakdown to construct the SQL query:\n\n**1. Identify the required data and tables:**\n- The question asks for the latest year in the GEM observations.\n- It's likely that there's a table containing GEM observations, which we'll call `gem_observations`.\n- This table probably has columns for the year of observation, but we'll need to determine the column name.\n\n**2. Identify the necessary columns:**\n- We need to select the column containing the year of observation. Let's assume it's named `year`.\n\n**3. Apply filters or conditions:**\n- There's no specific filter mentioned in the question, so we'll assume we want to consider all observations.\n- However, if there are any specific conditions (e.g., observation type, location), we'd include a filter for those.\n\n**4. Determine the aggregation or calculation:**\n- Since we want the latest year, we don't need any aggregation (e.g., sum, average) but rather a simple selection of the maximum year value.\n\n**5. Construct the SQL query:**\nHere's a possible SQL query to answer the question:\n\n```sql\nSELECT MAX(year) AS latest_year\nFROM gem_observations;\n```\n\nThis query selects the maximum value in the `year` column from the `gem_observations` table, which corresponds to the latest year in the GEM observations.\n\n**Assumptions:**\n- The `year` column is of a type that allows comparison and aggregation (e.g., integer, date).\n- The `gem_observations` table exists and has the required columns.\n\n**Note:** If there are multiple years with the same maximum value, this query will return one of them arbitrarily. If you want to return all maximum years, you might need to use a different approach, such as using a subquery or a window function.",
    "augmentation_type": "cot",
    "original_question": "What is the latest year in the GEM observations?"
  },
  {
    "id": 16,
    "question": "List all GFS indicator names that contain 'Expense'",
    "ground_truth_sql": "SELECT DISTINCT indicator_name FROM indicators WHERE source = 'GFS' AND indicator_name LIKE '%Expense%'",
    "difficulty": "simple",
    "category": "pattern_match",
    "reasoning": "Here's a step-by-step breakdown of how to construct the SQL query to answer the question:\n\n1. **Understand the question**: We need to list all GFS (General Financial Statement) indicator names that contain the word 'Expense'.\n\n2. **Determine the necessary data**: We need the GFS indicator names, which are likely stored in a table related to financial statements or accounting data.\n\n3. **Choose the relevant tables/columns**: Let's assume the table is called `financial_indicators`. The columns we need are:\n   - `indicator_name`: This column stores the name of the financial indicator.\n   - `indicator_type`: This column stores the type of financial indicator, which is likely 'GFS'.\n\n4. **Apply the necessary filter or condition**: We need to filter the results to include only rows where the `indicator_name` contains the word 'Expense'.\n\n5. **Construct the SQL query**: Here's the SQL query that meets the requirements:\n   ```sql\nSELECT indicator_name\nFROM financial_indicators\nWHERE indicator_type = 'GFS' AND indicator_name LIKE '%Expense%';\n```\n\n6. **Optional: Remove duplicates**: If there are duplicate indicator names, we might want to remove them to avoid repetition in the results. We can use the `DISTINCT` keyword to achieve this:\n   ```sql\nSELECT DISTINCT indicator_name\nFROM financial_indicators\nWHERE indicator_type = 'GFS' AND indicator_name LIKE '%Expense%';\n```\n\n7. **Test the query**: Execute the query to verify that it produces the desired results.\n\nThis query will return a list of unique GFS indicator names that contain the word 'Expense'.",
    "augmentation_type": "cot",
    "original_question": "List all GFS indicator names that contain 'Expense'"
  },
  {
    "id": 17,
    "question": "How many countries are in the database?",
    "ground_truth_sql": "SELECT COUNT(*) AS country_count FROM countries",
    "difficulty": "simple",
    "category": "count",
    "reasoning": "Here's the step-by-step breakdown to construct the SQL query:\n\n**1. Identify the required data:**\nTo answer the question, we need to know the total count of unique countries in the database.\n\n**2. Identify the relevant table(s) and column(s):**\nWe'll likely need a table that contains country information, such as a \"countries\" or \"locations\" table. Let's assume we have a table named \"countries\" with a column named \"country_name\" that stores the country names.\n\n**3. Apply filters or conditions:**\nNo filters or conditions are needed in this case, as we want to count all countries in the database.\n\n**4. Determine the required aggregation or calculation:**\nWe need to perform a COUNT aggregation on the unique country names. Since we're interested in the total count of countries, we can use the COUNT() function with the DISTINCT keyword to avoid counting duplicate country names.\n\n**5. Construct the SQL query:**\nPutting it all together, the SQL query would be:\n```sql\nSELECT COUNT(DISTINCT country_name) AS total_countries\nFROM countries;\n```\nThis query will return a single value, the total count of unique countries in the database, which is what we need to answer the original question.\n\nNote: Depending on the database management system (DBMS), the syntax might vary slightly. This example assumes a generic SQL syntax.",
    "augmentation_type": "cot",
    "original_question": "How many countries are in the database?"
  },
  {
    "id": 18,
    "question": "Find the country ID for Brazil",
    "ground_truth_sql": "SELECT country_id, country_name FROM countries WHERE country_name = 'Brazil'",
    "difficulty": "simple",
    "category": "lookup",
    "reasoning": "Here's a step-by-step guide to construct the SQL query:\n\n1. **Determine the required data**: We need to find the country ID for Brazil. This means we will require a table that contains country information.\n\n2. **Identify the relevant tables/columns**: Typically, country information is stored in a \"countries\" or \"country\" table. We will need to use this table and specifically look for the column that stores the country ID and the country name. Let's assume the table name is \"countries\" and the columns are \"country_id\" and \"country_name\".\n\n3. **Apply filters or conditions**: We need to filter the results to only include the country \"Brazil\". We can apply a condition or filter to the country_name column to achieve this.\n\n4. **Construct the query**: Based on the identified table and columns, we will create a SELECT statement to retrieve the country ID for Brazil. The basic query structure will be:\n   ```sql\nSELECT country_id\nFROM countries\n```\n   We will then add the filter condition to the query:\n   ```sql\nSELECT country_id\nFROM countries\nWHERE country_name = 'Brazil';\n```\n   This query will return the country ID for Brazil.\n\n**Final Query:**\n```sql\nSELECT country_id\nFROM countries\nWHERE country_name = 'Brazil';\n```",
    "augmentation_type": "cot",
    "original_question": "Find the country ID for Brazil"
  },
  {
    "id": 19,
    "question": "How many GEM observations are from the year 2020?",
    "ground_truth_sql": "SELECT COUNT(*) AS obs_count FROM gem_observations WHERE year = 2020",
    "difficulty": "simple",
    "category": "count_filtered",
    "reasoning": "Here's a step-by-step guide to constructing the SQL query:\n\n**1. Identify the necessary data:**\nWe need to find the number of GEM observations from the year 2020. This means we require data related to GEM observations and their corresponding dates.\n\n**2. Select the relevant tables/columns:**\nAssuming we have a database schema with the following tables:\n\n- `gem_observations`: This table stores information about GEM observations, including their respective dates.\n- `gem_observations` table likely has columns like `id`, `date`, and `observation_value`.\n\nWe will use the `gem_observations` table, specifically the `date` column to filter for observations from 2020.\n\n**3. Apply filters or conditions:**\nTo get the GEM observations from the year 2020, we need to filter the data based on the `date` column. Assuming the date is stored in a format that can be easily compared, we can use the following condition:\n\n- `date` >= '2020-01-01' AND `date` < '2021-01-01'\n\nThis will give us all the observations from January 1, 2020, to December 31, 2020.\n\n**4. Determine the necessary aggregation or calculation:**\nWe simply need to count the number of GEM observations that satisfy the filter condition. Therefore, we will use the `COUNT()` function to get the total count.\n\nHere's the step-by-step SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM gem_observations \nWHERE date >= '2020-01-01' AND date < '2021-01-01';\n```\n\nThis query will return the total count of GEM observations from the year 2020.",
    "augmentation_type": "cot",
    "original_question": "How many GEM observations are from the year 2020?"
  },
  {
    "id": 20,
    "question": "List all available sectors in the GFS data",
    "ground_truth_sql": "SELECT sector_name FROM sectors ORDER BY sector_name",
    "difficulty": "simple",
    "category": "select_all",
    "reasoning": "To answer the question, \"List all available sectors in the GFS data,\" we will follow these steps:\n\n1. **Understand the data structure**: The problem mentions \"GFS data,\" which suggests we are working with a dataset related to the General Fund Statement (GFS). We need to identify the relevant tables and columns in the database that hold this data.\n\n2. **Identify the necessary tables and columns**: \n   - We need a table that contains information about sectors, likely a table named `sectors` or `gfs_sectors`.\n   - This table may have a column named `sector_name` or `sector_id` that stores the sector names.\n\n3. **Apply no filters or conditions**: Since we are asked to list all available sectors, we will not apply any filters or conditions to the data. This means we can use a simple `SELECT` statement without any `WHERE` clause.\n\n4. **Choose the necessary columns**: We only need to retrieve the sector names, so we will select the column that stores sector names.\n\n5. **Construct the SQL query**:\n   - **Step 1**: Specify the table and column to select. \n     ```sql\n   SELECT sector_name\n   ```\n   - **Step 2**: Specify the table from which to retrieve the data. \n     ```sql\n   FROM gfs_sectors\n   ```\n   - **Step 3**: Combine the previous two steps into a single query.\n     ```sql\n   SELECT sector_name\n   FROM gfs_sectors\n   ```\n\n6. **Execute the query**: Run the constructed query on the database to retrieve the list of available sectors.\n\nThe final SQL query to answer the question is:\n\n```sql\nSELECT sector_name\nFROM gfs_sectors\n```",
    "augmentation_type": "cot",
    "original_question": "List all available sectors in the GFS data"
  },
  {
    "id": 21,
    "question": "How many GFS observations are from the year 2020?",
    "ground_truth_sql": "SELECT COUNT(*) AS obs_count FROM gfs_observations WHERE year = 2020",
    "difficulty": "simple",
    "category": "count_filtered",
    "reasoning": "Here's a step-by-step guide to construct the SQL query:\n\n1. **Determine the data needed**: We need to find the count of GFS (Global Forecast System) observations from the year 2020.\n\n2. **Identify the relevant tables and columns**: \n   - GFS observations are typically stored in a table named something like `observations` or `gfs_observations`.\n   - The columns we'll need are:\n     - `obs_date`: The date the observation was made.\n     - `gfs_id` or `gfs_obs_id`: A unique identifier for the GFS observation.\n     - `count`: The number of observations (we might use this column to filter or aggregate, but in this case, we only need the count of rows).\n\n3. **Apply filters or conditions**: \n   - We need to filter observations from the year 2020. We can use the `obs_date` column to extract the year using the `YEAR` function (assuming the column is of a date type).\n   - The `WHERE` clause should filter observations where the year is 2020.\n\n4. **Define the aggregation or calculation**: \n   - Since we want to know the total count of GFS observations from the year 2020, we can use the `COUNT` aggregation function.\n\n5. **Write the SQL query**:\n   ```sql\nSELECT COUNT(*) \nFROM gfs_observations \nWHERE YEAR(obs_date) = 2020;\n```\nThis query will return the total count of GFS observations from the year 2020. \n\nNote: The actual table and column names might be different based on the specific database schema. This is just an example of how to construct the query based on typical use cases.",
    "augmentation_type": "cot",
    "original_question": "How many GFS observations are from the year 2020?"
  },
  {
    "id": 22,
    "question": "List countries with GFS data available for 2023",
    "ground_truth_sql": "SELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE g.year = 2023\nORDER BY c.country_name",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "**Constructing the SQL Query: List countries with GFS data available for 2023**\n\n**Step 1: Identify the required data**\n\nWe need to identify the tables and columns required to answer the question. The data needed includes:\n\n* Country information (name, ID, etc.)\n* GFS data availability for 2023\n\nAssuming the database schema includes the following tables:\n\n* `countries` (contains country information)\n* `gfs_data` (contains GFS data, including year and country ID)\n\n**Step 2: Choose the relevant tables and columns**\n\nTo answer the question, we need to use the `countries` table to retrieve the country information and the `gfs_data` table to check for GFS data availability in 2023.\n\n* `countries` table: `id`, `name` columns\n* `gfs_data` table: `year`, `country_id` columns\n\n**Step 3: Apply filters and conditions**\n\nTo get the countries with GFS data available for 2023, we need to apply the following filters:\n\n* Filter the `gfs_data` table for the year 2023\n* Filter the `gfs_data` table to include only rows where `country_id` exists in the `countries` table\n\n**Step 4: Choose the aggregation or calculation**\n\nSince we want to list the countries with GFS data available for 2023, we don't need to perform any aggregations or calculations.\n\n**Step 5: Construct the SQL query**\n\nUsing the identified tables, columns, filters, and aggregations, we can construct the SQL query as follows:\n\n```sql\nSELECT c.id, c.name\nFROM countries c\nJOIN gfs_data g ON c.id = g.country_id\nWHERE g.year = 2023;\n```\n\nThis query joins the `countries` table with the `gfs_data` table on the `country_id` column, filters the result to include only rows with a year of 2023, and selects the `id` and `name` columns from the `countries` table.",
    "augmentation_type": "cot",
    "original_question": "List countries with GFS data available for 2023"
  },
  {
    "id": 23,
    "question": "List all years where France has general government GFS data",
    "ground_truth_sql": "SELECT DISTINCT g.year\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE c.country_name = 'France'\nAND s.sector_name = 'General government'\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "To answer the question \"List all years where France has general government GFS data,\" follow these steps:\n\n1. **Identify the required data**: We need information about the years when France has general government GFS data.\n\n2. **Determine the relevant tables/columns**: Assuming we have a database with the following tables:\n   - `countries`: contains information about countries, including their names and codes.\n   - `gfs_data`: contains general government GFS data, which includes a `country_code`, `year`, and other relevant information.\n   \n   We will use the `gfs_data` table to get the necessary data.\n\n3. **Apply filters or conditions**: We need to filter the data to include only rows where the country is France. To do this, we will use the `country_code` column in the `gfs_data` table to match the code for France.\n\n4. **Aggregate or calculate the data (if necessary)**: In this case, we don't need any aggregations or calculations, as we just want a list of years.\n\n5. **Write the SQL query**: Based on the previous steps, the query would be:\n   ```sql\nSELECT DISTINCT year\nFROM gfs_data\nWHERE country_code = 'FRA';\n```\n   This query selects the distinct `year` values from the `gfs_data` table where the `country_code` is 'FRA', which is the code for France.\n\n6. **Consider any additional requirements**: If there are any additional requirements, such as sorting or limiting the output, they can be added to the query as needed.",
    "augmentation_type": "cot",
    "original_question": "List all years where France has general government GFS data"
  },
  {
    "id": 24,
    "question": "Show total government expenditure (percent of GDP) for Brazil from 2015 to 2022",
    "ground_truth_sql": "SELECT g.year, g.value AS expenditure_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2015 AND 2022\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here's a step-by-step breakdown to construct the SQL query:\n\n**1. Determine the necessary data and tables**\nTo answer the question, we need data related to government expenditure and GDP for Brazil from 2015 to 2022. This data is likely available in a database that tracks economic indicators. We'll assume the database has two primary tables:\n\n- `gdp_table`: contains GDP data for various countries and years.\n- `government_expenditure_table`: contains government expenditure data for various countries and years.\n\n**2. Identify the relevant columns**\nWe need the following columns to answer the question:\n\n- `country`: to filter for Brazil\n- `year`: to filter for the desired years (2015 to 2022)\n- `gdp`: to calculate the total GDP\n- `government_expenditure`: to calculate the total government expenditure\n\n**3. Apply filters and conditions**\nTo answer the question, we need to apply the following filters and conditions:\n\n- Filter for the country \"Brazil\" in the `country` column\n- Filter for the years 2015 to 2022 in the `year` column\n- Ensure the data is not missing or null for the required columns\n\n**4. Perform aggregations and calculations**\nWe need to perform the following aggregations and calculations:\n\n- Calculate the total GDP by summing up the `gdp` values for each year\n- Calculate the total government expenditure by summing up the `government_expenditure` values for each year\n- Calculate the government expenditure as a percentage of GDP by dividing the total government expenditure by the total GDP and multiplying by 100\n\n**Here's the resulting SQL query:**\n\n```sql\nSELECT \n  year,\n  (SUM(government_expenditure) / SUM(gdp)) * 100 AS government_expenditure_percent_of_gdp\nFROM \n  (\n    SELECT \n      gdp_table.year,\n      government_expenditure_table.government_expenditure,\n      government_expenditure_table.gdp\n    FROM \n      gdp_table\n    INNER JOIN \n      government_expenditure_table ON gdp_table.country = government_expenditure_table.country AND gdp_table.year = government_expenditure_table.year\n    WHERE \n      gdp_table.country = 'Brazil' AND gdp_table.year BETWEEN 2015 AND 2022\n  ) AS subquery\nGROUP BY \n  year\nORDER BY \n  year;\n```\n\nThis SQL query will return the total government expenditure as a percentage of GDP for Brazil from 2015 to 2022.",
    "augmentation_type": "cot",
    "original_question": "Show total government expenditure (percent of GDP) for Brazil from 2015 to 2022"
  },
  {
    "id": 25,
    "question": "What is the average revenue (percent of GDP) for general government in 2020 across all countries?",
    "ground_truth_sql": "SELECT AVG(g.value) AS avg_revenue_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = 'General government'\nAND i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year = 2020",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "Here's a step-by-step breakdown to construct the SQL query:\n\n**1. Identify the required data and tables**\n\n- We need the following information:\n  - Average revenue (percent of GDP) for general government in 2020\n  - This requires data on revenue, GDP, and general government information\n- The relevant tables are likely to be:\n  - A table with country-level data (e.g., \"countries\")\n  - A table with economic data (e.g., \"economic_data\" or \"gdp_data\")\n  - A table with government revenue data (e.g., \"government_revenue\" or \"revenue_data\")\n\n**2. Choose the necessary columns**\n\n- **Countries table**:\n  - country_id or country_name (to identify countries)\n  - year (to filter for 2020)\n- **Economic data table**:\n  - country_id (to link to countries table)\n  - gdp (to calculate percent of GDP)\n  - year (to filter for 2020)\n- **Government revenue table**:\n  - country_id (to link to countries table)\n  - revenue (to calculate average revenue)\n  - year (to filter for 2020)\n\n**3. Apply filters and conditions**\n\n- Filter the data to include only countries with available data for 2020\n- Filter the data to include only general government revenue\n- Filter the data to include only the year 2020\n\n**4. Perform aggregations and calculations**\n\n- Calculate the average revenue for general government in 2020 across all countries\n- Express the revenue as a percent of GDP\n\n**5. Construct the SQL query**\n\n- Use `JOIN` statements to link the relevant tables\n- Apply the filters and conditions using `WHERE` and `AND` clauses\n- Perform the aggregations and calculations using `AVG`, `SUM`, and `DIV` functions\n- Express the revenue as a percent of GDP using a calculation or a window function\n\nHere's a sample SQL query based on these steps:\n```sql\nSELECT \n  AVG(gre.revenue) AS avg_revenue_percent_gdp\nFROM \n  countries c\n  JOIN economic_data ed ON c.country_id = ed.country_id\n  JOIN government_revenue gre ON c.country_id = gre.country_id\nWHERE \n  ed.year = 2020\n  AND gre.year = 2020\n  AND gre.revenue_source = 'general government';\n```\nNote that the actual query may vary depending on the specific table and column names, as well as the database management system being used.",
    "augmentation_type": "cot",
    "original_question": "What is the average revenue (percent of GDP) for general government in 2020 across all countries?"
  },
  {
    "id": 26,
    "question": "What is the total count of observations per GEM indicator?",
    "ground_truth_sql": "SELECT i.indicator_name, i.unit, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nGROUP BY i.indicator_name, i.unit\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "Here's the step-by-step breakdown to construct the SQL query:\n\n**1. What data is needed?**\nWe need to extract the total count of observations per GEM (Global Economic Monitor) indicator.\n\n**2. Which tables/columns to use?**\nGiven the context, we'll assume there are two relevant tables:\n- `gem_indicators` (contains GEM indicators and their details)\n- `observations` (contains data points for each GEM indicator)\n\nWe'll use the following columns:\n- `indicator_id` (foreign key linking to `gem_indicators`)\n- `count` (column representing the count of observations)\n\n**3. What filters or conditions to apply?**\nWe're interested in the total count of observations per GEM indicator, so we don't need to apply any specific filters or conditions in this case.\n\n**4. What aggregations or calculations are needed?**\nWe want to calculate the total count of observations per GEM indicator, which can be achieved by using the `GROUP BY` clause and `COUNT()` aggregation function.\n\nHere's the SQL query:\n\n```sql\nSELECT \n  gi.indicator_name,\n  COUNT(o.count) AS total_count\nFROM \n  observations o\n  JOIN gem_indicators gi ON o.indicator_id = gi.indicator_id\nGROUP BY \n  gi.indicator_name;\n```\n\nThis query will return the total count of observations for each GEM indicator.\n\n**Assumptions:**\n\n- `indicator_name` is the column in the `gem_indicators` table that contains the GEM indicator names.\n- The `observations` table has a foreign key `indicator_id` that links to the `gem_indicators` table.\n\n**Note:** The actual table and column names may vary depending on the database schema.",
    "augmentation_type": "cot",
    "original_question": "What is the total count of observations per GEM indicator?"
  },
  {
    "id": 27,
    "question": "Count GFS observations by scale type",
    "ground_truth_sql": "SELECT scale, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY scale\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "aggregation",
    "reasoning": "To construct the SQL query and answer the question \"Count GFS observations by scale type,\" follow these steps:\n\n1. **Determine the required data**: We need a table that contains GFS observations and their corresponding scale types. Let's assume the table is named `gfs_observations`.\n\n2. **Identify the necessary columns**: We need two columns:\n   - `scale_type`: This column will contain the different scale types (e.g., 'fine', 'medium', 'coarse').\n   - `id` or a similar column: This column will be used to identify the GFS observations, but we're only interested in counting them, so we can use it in the `GROUP BY` clause.\n\n3. **Apply filters or conditions (if any)**: In this case, we don't have any specific filters or conditions to apply. We want to count all GFS observations by scale type.\n\n4. **Choose the aggregation or calculation**: Since we want to count the GFS observations by scale type, we'll use the `COUNT` aggregation function.\n\n5. **Write the basic SQL query structure**: The basic structure will be:\n   ```sql\nSELECT \n  scale_type,\n  COUNT(*) AS count\nFROM \n  gfs_observations\nGROUP BY \n  scale_type;\n```\n   However, we might need to adjust this structure based on the actual table schema and column names.\n\n6. **Check for any additional requirements**: If we need to consider only a specific period or state, we would add the corresponding filter conditions.\n\n7. **Finalize the query**: Based on the above steps, the final SQL query should look something like this:\n   ```sql\nSELECT \n  scale_type,\n  COUNT(*) AS count\nFROM \n  gfs_observations\nGROUP BY \n  scale_type;\n```\nThis query will return the count of GFS observations for each scale type.\n\n**Additional considerations:**\n\n- If the `scale_type` column is not defined as a string, we might need to modify the query to handle the data type correctly.\n- If the table has a very large number of rows, we might need to optimize the query using indexes or efficient grouping methods.\n- If the query is part of a larger process, we might need to add error handling or logging to ensure the query runs successfully and produces the expected results.",
    "augmentation_type": "cot",
    "original_question": "Count GFS observations by scale type"
  },
  {
    "id": 28,
    "question": "Count how many countries have GEM unemployment data for each year",
    "ground_truth_sql": "SELECT g.year, COUNT(DISTINCT g.country_id) AS country_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nGROUP BY g.year\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "**Step-by-Step Guide to Constructing the SQL Query**\n\n1. **Data Needed:**\n   To answer this question, we need data on countries and their unemployment rates. Specifically, we need the following:\n   - A list of countries\n   - Unemployment rates (GEM) for each country\n   - The corresponding year for each unemployment rate\n\n2. **Tables/Columns to Use:**\n   To get the required data, we can use the following tables and columns:\n   - `countries`: a table containing information on all countries (e.g., country name, code, etc.)\n   - `unemployment_rates`: a table containing unemployment rates for each country (GEM data) along with the corresponding year\n\n3. **Filters/Conditions to Apply:**\n   To get the required data, we need to apply the following filters:\n   - `unemployment_rates` table: filter for GEM unemployment data (e.g., using a specific column or value to identify GEM data)\n   - `countries` table: filter for countries that have GEM unemployment data (e.g., using a specific column or value to identify countries with available GEM data)\n\n4. **Aggregations/Calculations Needed:**\n   To answer the question, we need to count how many countries have GEM unemployment data for each year. This requires:\n   - Grouping the data by year\n   - Counting the number of countries with GEM unemployment data for each year\n\n**SQL Query:**\n```sql\nSELECT \n  u.year,\n  COUNT(DISTINCT c.country_name) AS num_countries\nFROM \n  unemployment_rates u\n  JOIN countries c ON u.country_id = c.country_id\nWHERE \n  u.data_source = 'GEM'  -- assuming 'GEM' is a specific value for GEM data\nGROUP BY \n  u.year;\n```\n**Explanation:**\n\n- We join the `unemployment_rates` table with the `countries` table on the `country_id` column.\n- We filter the data to only include GEM unemployment rates using the `data_source` column.\n- We group the data by year using the `GROUP BY` clause.\n- We count the number of distinct countries with GEM unemployment data for each year using the `COUNT(DISTINCT)` function.\n- We alias the result as `num_countries` for clarity.",
    "augmentation_type": "cot",
    "original_question": "Count how many countries have GEM unemployment data for each year"
  },
  {
    "id": 29,
    "question": "Count the number of countries with GEM data for each year",
    "ground_truth_sql": "SELECT year, COUNT(DISTINCT country_id) AS country_count\nFROM gem_observations\nGROUP BY year\nORDER BY year",
    "difficulty": "medium",
    "category": "aggregation",
    "reasoning": "To answer the question \"Count the number of countries with GEM data for each year,\" follow these steps:\n\n1. **Determine the necessary data and tables:**\n   - We need data on countries and their GEM (Global Entrepreneurship Monitor) scores.\n   - The required tables are likely \"Countries\" and \"GEM_Data\" (or any similar table containing the GEM data).\n\n2. **Identify the relevant columns:**\n   - We need the \"Country\" column to identify the countries.\n   - We need the \"Year\" column to determine the year for which we want to count the countries with GEM data.\n   - We may need the \"GEM_Data\" column to confirm if the country has GEM data.\n\n3. **Apply filters and conditions:**\n   - We want to count only the countries with GEM data, so we need a filter to select only rows where the GEM data is available.\n   - We can use a \"NOT NULL\" condition to filter out rows where the GEM data is missing.\n\n4. **Perform aggregations or calculations:**\n   - We need to count the number of countries with GEM data for each year, so we will use the COUNT() aggregation function.\n   - Since we want the count for each year, we will group the results by the \"Year\" column.\n\nHere's a sample SQL query that follows these steps:\n\n```sql\nSELECT \n  YEAR,\n  COUNT(Country) AS Number_of_Countries\nFROM \n  Countries\n  INNER JOIN GEM_Data ON Countries.Country = GEM_Data.Country\nWHERE \n  GEM_Data.GEM_Data IS NOT NULL\nGROUP BY \n  YEAR\nORDER BY \n  YEAR;\n```\n\nThis query joins the \"Countries\" table with the \"GEM_Data\" table on the \"Country\" column, filters out rows where the GEM data is missing, groups the results by the \"Year\" column, and counts the number of countries with GEM data for each year.",
    "augmentation_type": "cot",
    "original_question": "Count the number of countries with GEM data for each year"
  },
  {
    "id": 30,
    "question": "List the 10 countries with the highest GDP (constant 2010 US$) in 2019",
    "ground_truth_sql": "SELECT c.country_name, g.value AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'GDP at market prices'\nAND i.unit = 'constant 2010 US$, millions'\nAND g.year = 2019\nORDER BY g.value DESC\nLIMIT 10",
    "difficulty": "medium",
    "category": "join_filter_limit",
    "reasoning": "**Step-by-Step Guide to Constructing the SQL Query**\n\n**1. Identify the required data:**\nWe need data on countries and their GDP (constant 2010 US$) in 2019.\n\n**2. Determine the necessary tables and columns:**\nWe will likely need:\n- A table with country information (e.g., `countries`)\n- A table with economic data (e.g., `gdp_data`)\n- A table with conversion rates (e.g., `conversion_rates`)\n\nWe will specifically need:\n- `country_id` or `country_name` to identify countries\n- `gdp` (in constant 2010 US$) to measure GDP\n- `year` to filter data for 2019\n\n**3. Apply filters and conditions:**\nWe need to filter the data for:\n- `year` = 2019\n- `gdp` in constant 2010 US$\n\n**4. Determine the required aggregation or calculation:**\nWe need to list the top 10 countries by `gdp` in constant 2010 US$.\n\n**5. Construct the SQL query:**\nBased on the above steps, a possible SQL query could be:\n```sql\nSELECT c.country_name, gd.gdp\nFROM countries c\nJOIN gdp_data gd ON c.country_id = gd.country_id\nJOIN conversion_rates cr ON gd.country_id = cr.country_id\nWHERE gd.year = 2019\nORDER BY gd.gdp DESC\nLIMIT 10;\n```\nHowever, note that the exact query will depend on the actual table structures and relationships in the database.\n\n**Additional considerations:**\n\n- We might need to use subqueries or window functions if we need to calculate the converted GDP values or perform more complex aggregations.\n- We should ensure that the data is accurately and consistently stored in the database tables.\n- We should also consider any potential performance implications of the query, such as indexing or joining large tables.",
    "augmentation_type": "cot",
    "original_question": "List the 10 countries with the highest GDP (constant 2010 US$) in 2019"
  },
  {
    "id": 31,
    "question": "What is the average value by sector for GFS observations in 2020?",
    "ground_truth_sql": "SELECT s.sector_name, AVG(g.value) AS avg_value\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE g.year = 2020\nGROUP BY s.sector_name\nORDER BY avg_value DESC",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "**Step 1: Identify the Data Needed**\nWe need to determine the average value by sector for GFS (Global Forecast System) observations in 2020. To achieve this, we require the following data:\n- Sector (or category)\n- Average value\n- Year (specifically 2020)\n\n**Step 2: Determine the Tables and Columns to Use**\nTo find the required data, we will likely need to use the following tables and columns:\n- `observations` table: stores individual observations with their respective values\n- `sectors` table: stores sector information\n- `forecast_systems` table: stores information about the forecast systems used (e.g., GFS)\n- `years` table: stores year information\n- `sector_values` table (optional): stores the average values by sector (if pre-calculated)\n\n**Step 3: Apply Filters and Conditions**\nBased on the question, the following conditions should be applied:\n- `forecast_systems.name = 'GFS'` to filter by the Global Forecast System\n- `years.year = 2020` to filter by the year 2020\n- `observations.value` (assuming it's the column that stores the value) to calculate the average value\n\n**Step 4: Aggregate and Calculate the Average Value**\nWe will use an aggregate function (e.g., `AVG`) to calculate the average value by sector. The SQL query should group the results by sector to provide the average value for each sector.\n\n**Step 5: Write the SQL Query**\nHere's an example SQL query that addresses the above steps:\n```sql\nSELECT \n  sv.sector_name, \n  AVG(ov.value) AS average_value\nFROM \n  observations ov\n  JOIN forecast_systems fs ON ov.forecast_system_id = fs.id\n  JOIN years y ON ov.year_id = y.id\n  JOIN sector_values sv ON ov.sector_id = sv.id\nWHERE \n  fs.name = 'GFS' \n  AND y.year = 2020\nGROUP BY \n  sv.sector_name;\n```\nThis query assumes a specific database schema and table structures. Adjustments may be necessary based on the actual database design.\n\n**Note:** If the `sector_values` table is not available or pre-calculated, you can remove the join with this table and use a subquery or the `AVG` function directly with the `observations` table.",
    "augmentation_type": "cot",
    "original_question": "What is the average value by sector for GFS observations in 2020?"
  },
  {
    "id": 32,
    "question": "Count the number of GFS observations per year for the United States",
    "ground_truth_sql": "SELECT g.year, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE c.country_name = 'United States'\nGROUP BY g.year\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "To count the number of GFS observations per year for the United States, follow these steps:\n\n1. **Identify the necessary data and tables**:\n   - We need data related to GFS observations.\n   - The table(s) containing this data is likely `gfs_observations` or a similar table name.\n   - Assume this table has the following columns:\n     - `id` (unique identifier)\n     - `year` (year of observation)\n     - `country` (country where the observation was made)\n     - `type` (type of observation, e.g., 'GFS')\n   - If the table structure is different, adjust accordingly.\n\n2. **Apply filters or conditions**:\n   - Filter the data to only include observations from the United States.\n   - Use the `country` column and set it to 'United States' or a code representing the United States.\n\n3. **Apply the GFS observations filter**:\n   - Filter the data to only include 'GFS' type observations.\n   - Use the `type` column and set it to 'GFS'.\n\n4. **Group the data by year**:\n   - Use the `YEAR` column to group the data by year.\n\n5. **Count the number of observations per year**:\n   - Apply the `COUNT` aggregation function to count the number of observations per year.\n\n6. **Construct the SQL query**:\n   ```sql\nSELECT \n  YEAR,\n  COUNT(id) AS gfs_count\nFROM \n  gfs_observations\nWHERE \n  country = 'United States'\n  AND type = 'GFS'\nGROUP BY \n  YEAR\nORDER BY \n  YEAR;\n```\n\n7. **Execute the query and interpret the results**:\n   - Execute the query and get the results.\n   - The results will show the number of GFS observations per year for the United States.",
    "augmentation_type": "cot",
    "original_question": "Count the number of GFS observations per year for the United States"
  },
  {
    "id": 33,
    "question": "Show terms of trade for Australia from 2010 to 2023",
    "ground_truth_sql": "SELECT g.year, g.value AS terms_of_trade\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\nAND i.indicator_name = 'Terms of Trade'\nAND g.year BETWEEN 2010 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "To answer the question \"Show terms of trade for Australia from 2010 to 2023\" with SQL, follow these steps:\n\n1. **Determine the data needed**: \n    - We need to calculate the terms of trade (TOT), which is typically measured as the ratio of export prices to import prices.\n    - The data required includes:\n        - Export prices\n        - Import prices\n        - The base year for prices (in this case, we'll assume 2010)\n    - We'll likely need data from an economic database or a dataset that provides trade statistics.\n\n2. **Choose the tables/columns**: \n    - Select the tables that contain the necessary data:\n        - `exports`: contains export prices and quantities\n        - `imports`: contains import prices and quantities\n    - Use the `date` column in these tables to filter by the required period (2010-2023).\n    - We'll likely need to join these tables on a common key, such as `country` or `year`.\n\n3. **Apply filters and conditions**:\n    - Filter the data by country (`Australia` or `AUS`) and date range (2010-2023).\n    - We may need to handle missing data or outliers in the price series.\n\n4. **Calculate the terms of trade (TOT)**:\n    - Use the formula: TOT = (Export Price Index / Import Price Index) * 100\n    - We'll need to calculate the export and import price indices for each year.\n\n5. **Write the SQL query**:\n    - Use the chosen tables and columns\n    - Apply the filters and conditions\n    - Calculate the TOT using the formula above\n    - Group the results by year (or another suitable time period)\n    - Order the results by year (optional)\n\nHere's an example SQL query:\n```sql\nSELECT \n  YEAR(date) AS year,\n  TOT\nFROM (\n  SELECT \n    YEAR(date) AS year,\n    (EXPORT_PRICE_INDEX / IMPORT_PRICE_INDEX) * 100 AS TOT\n  FROM \n    exports e\n  INNER JOIN \n    imports i ON e.year = i.year AND e.country = i.country\n  WHERE \n    e.country = 'Australia' AND e.year BETWEEN 2010 AND 2023\n) t\nORDER BY \n  year;\n```\nNote: This is a simplified example. In practice, you may need to handle more complex data and calculations, such as seasonally adjusted prices or more sophisticated econometric models.",
    "augmentation_type": "cot",
    "original_question": "Show terms of trade for Australia from 2010 to 2023"
  },
  {
    "id": 34,
    "question": "Show the exchange rate for Mexico from 2015 to 2023",
    "ground_truth_sql": "SELECT g.year, g.value AS exchange_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Mexico'\nAND i.indicator_name = 'Exchange rate'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here's the logical breakdown to construct the SQL query:\n\n**1. Identify the required data**\n- We need the exchange rate data for Mexico.\n- The time range is from 2015 to 2023.\n\n**2. Determine the necessary tables and columns**\n- Typically, exchange rate data is stored in a table called 'exchange_rates' or similar.\n- The required columns are:\n  - 'country' or 'currency' (to filter for Mexico)\n  - 'date' or 'timestamp' (to filter the time range)\n  - 'exchange_rate' (the actual exchange rate value)\n\n**3. Apply filters and conditions**\n- Filter the data by country: we're only interested in Mexico's exchange rates.\n- Apply a date range filter: we want the data from 2015 to 2023.\n\n**4. Determine aggregations or calculations**\n- Since the exchange rate is likely to change frequently, we don't need to aggregate the data.\n- We only need to retrieve the latest (or most up-to-date) exchange rate for each year, if needed, or all the exchange rates for the specified time period.\n\n**5. Construct the SQL query**\n```sql\nSELECT \n  country,\n  date,\n  exchange_rate\nFROM \n  exchange_rates\nWHERE \n  country = 'Mexico'\n  AND date >= '2015-01-01'\n  AND date <= '2023-12-31';\n```\n\nHowever, note that this query may return multiple rows for each year, if the exchange rate changed multiple times in that year. To get the latest exchange rate for each year, we would need to add a subquery or use a window function.\n\n**Alternative query to get the latest exchange rate for each year**\n```sql\nSELECT \n  country,\n  date,\n  exchange_rate\nFROM (\n  SELECT \n    country,\n    date,\n    exchange_rate,\n    ROW_NUMBER() OVER (PARTITION BY country, EXTRACT(YEAR FROM date) ORDER BY date DESC) AS row_num\n  FROM \n    exchange_rates\n  WHERE \n    country = 'Mexico'\n    AND date >= '2015-01-01'\n    AND date <= '2023-12-31'\n) subquery\nWHERE \n  row_num = 1;\n```\nThis alternative query uses a window function (ROW_NUMBER) to assign a unique number to each row within each group (country and year), and then selects the row with row_num = 1 to get the latest exchange rate for each year.",
    "augmentation_type": "cot",
    "original_question": "Show the exchange rate for Mexico from 2015 to 2023"
  },
  {
    "id": 35,
    "question": "List countries and the number of GFS observations for each",
    "ground_truth_sql": "SELECT c.country_name, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "To answer the question \"List countries and the number of GFS observations for each,\" we'll break down the process into clear, logical steps.\n\n**Step 1: Identify the necessary data**\n\n* We need to retrieve information about countries and the number of GFS (Global Forecast System) observations for each.\n* We're likely working with a database that contains weather or climate data.\n\n**Step 2: Determine the relevant tables and columns**\n\n* We'll need a table that contains country information, such as `countries` or `locations`.\n* We'll also need a table that contains GFS observation data, such as `gfs_observations` or `model_data`.\n* The `countries` table likely contains columns like `country_id`, `country_name`, and `iso_code`.\n* The `gfs_observations` table likely contains columns like `observation_id`, `country_id`, and `observation_date`.\n\n**Step 3: Apply filters or conditions**\n\n* We only care about GFS observations, so we'll filter the data to include only rows from the `gfs_observations` table.\n* We're interested in the number of observations for each country, so we'll group the results by `country_id`.\n\n**Step 4: Perform aggregations or calculations**\n\n* We need to count the number of GFS observations for each country, so we'll use the `COUNT` aggregation function.\n\n**Step 5: Write the SQL query**\n\nHere's the resulting SQL query:\n```sql\nSELECT \n  c.country_name, \n  COUNT(go.observation_id) AS num_observations\nFROM \n  countries c\n  JOIN gfs_observations go ON c.country_id = go.country_id\nGROUP BY \n  c.country_name;\n```\nThis query:\n\n1. Joins the `countries` table with the `gfs_observations` table on the `country_id` column.\n2. Groups the results by `country_name`.\n3. Counts the number of `observation_id` values for each group using `COUNT`.\n4. Returns the `country_name` and the count of observations for each country.\n\nNote: This assumes that the `observation_id` column in the `gfs_observations` table is unique for each observation. If there are multiple observations with the same `observation_id`, the count will not be accurate.",
    "augmentation_type": "cot",
    "original_question": "List countries and the number of GFS observations for each"
  },
  {
    "id": 36,
    "question": "What is the maximum unemployment rate recorded in GEM data and which country-year?",
    "ground_truth_sql": "SELECT c.country_name, g.year, g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nORDER BY g.value DESC\nLIMIT 1",
    "difficulty": "medium",
    "category": "join_filter_limit",
    "reasoning": "To answer the question \"What is the maximum unemployment rate recorded in GEM data and which country-year?\", follow these steps:\n\n**1. Identify the required data and tables/columns**\n\n* Tables: GEM data table (assuming it's named `gem_data`)\n* Columns:\n\t+ `unemployment_rate`: column containing the unemployment rate data\n\t+ `country`: column containing the country names\n\t+ `year`: column containing the year data\n\t+ `id` (optional): column serving as a unique identifier for each country-year record\n\n**2. Apply filters or conditions**\n\n* Identify the relevant data: assume the GEM data contains unemployment rates for multiple countries and years. To focus on the maximum recorded rate, we don't need to apply any specific filters for now.\n\n**3. Determine the required aggregation or calculation**\n\n* We need to find the maximum unemployment rate, which means we'll use the `MAX` aggregation function on the `unemployment_rate` column.\n* To identify the country-year where this maximum rate was recorded, we'll need to select the corresponding `country` and `year` values along with the `id` (if available) for the row with the maximum `unemployment_rate`.\n\n**4. Construct the SQL query**\n\nHere's the SQL query that combines the steps above:\n```sql\nSELECT \n  country,\n  year,\n  id,\n  unemployment_rate\nFROM \n  gem_data\nWHERE \n  (country, year) IN (\n    SELECT \n      country,\n      year\n    FROM \n      gem_data\n    ORDER BY \n      unemployment_rate DESC\n    LIMIT 1\n  );\n```\nHowever, this query has a subquery that might not be the most efficient way to get the maximum unemployment rate. \n\nA more efficient approach would be to use a `ROW_NUMBER()` or `RANK()` function to assign a ranking to each country-year record based on the `unemployment_rate`. Then, we can select the country-year with the highest ranking.\n\nHere's an alternative query:\n```sql\nWITH ranked_data AS (\n  SELECT \n    country,\n    year,\n    id,\n    unemployment_rate,\n    ROW_NUMBER() OVER (ORDER BY unemployment_rate DESC) AS rank\n  FROM \n    gem_data\n)\nSELECT \n  country,\n  year,\n  id,\n  unemployment_rate\nFROM \n  ranked_data\nWHERE \n  rank = 1;\n```\nThis approach should be more efficient, especially for larger datasets.",
    "augmentation_type": "cot",
    "original_question": "What is the maximum unemployment rate recorded in GEM data and which country-year?"
  },
  {
    "id": 37,
    "question": "Show GDP at market prices for the United States for all available years",
    "ground_truth_sql": "SELECT g.year, g.value AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'United States'\nAND i.indicator_name = 'GDP at market prices'\nAND i.unit = 'constant 2010 US$, millions'\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here's the step-by-step process to construct the SQL query:\n\n**1. Identify the data needed:**\nWe need to retrieve the GDP at market prices for the United States for all available years. \n\n**2. Determine the tables and columns to use:**\nBased on common economic datasets, we'll assume the following tables and columns are available:\n- `GDP`: A table containing GDP data with the following columns:\n  - `Country`: The country code (e.g., USA for the United States)\n  - `Year`: The year the GDP data applies to\n  - `GDP_Market_Price`: The GDP at market prices for the respective country and year\n\n**3. Apply filters or conditions:**\nWe need to filter the data for the United States (Country = 'USA') and include all available years.\n\n**4. Construct the SQL query:**\nHere's the step-by-step construction of the query:\n\n- **Step 4.1:** Select the column(s) of interest (GDP at market prices)\n  - `SELECT GDP_Market_Price`\n- **Step 4.2:** Specify the table(s) to query\n  - `FROM GDP`\n- **Step 4.3:** Apply the filter for the United States\n  - `WHERE Country = 'USA'`\n- **Step 4.4:** Include all available years by removing any limitations on the year column\n  - No additional conditions are necessary for this step\n\n**The final SQL query:**\n```sql\nSELECT GDP_Market_Price\nFROM GDP\nWHERE Country = 'USA';\n```\nThis query will return the GDP at market prices for the United States for all available years.",
    "augmentation_type": "cot",
    "original_question": "Show GDP at market prices for the United States for all available years"
  },
  {
    "id": 38,
    "question": "Find country-years with high unemployment rate (>10%) from GEM data between 2010 and 2020",
    "ground_truth_sql": "SELECT\n    c.country_name,\n    g.year,\n    g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\n    AND g.year BETWEEN 2010 AND 2020\n    AND g.value > 10\nORDER BY g.value DESC",
    "difficulty": "medium",
    "category": "filtering",
    "reasoning": "**Step 1: Identify the necessary tables and columns**\n\n* We will need the `countries` table to access country information, and the `gem_data` table as the main data source for unemployment rate information.\n* Specifically, we will use the `country_id`, `year`, and `unemployment_rate` columns from the `gem_data` table.\n\n**Step 2: Filter the data to the desired time range**\n\n* Apply a filter to the `year` column to include only data from 2010 to 2020.\n* This will ensure we're only considering the relevant years for our analysis.\n\n**Step 3: Apply the unemployment rate filter (>10%)**\n\n* Use a filter to select only rows where the `unemployment_rate` is greater than 10%.\n* This will isolate the country-years with high unemployment rates.\n\n**Step 4: Determine the desired output**\n\n* We want to retrieve the country-years with high unemployment rates, so we'll include the `country_id` and `year` columns in our query.\n* To provide more context, we might also want to include the `country_name` from the `countries` table, but this is optional.\n\n**Step 5: Construct the SQL query**\n\nHere's the SQL query that implements the steps above:\n```sql\nSELECT \n  c.country_name, \n  g.year, \n  g.unemployment_rate\nFROM \n  gem_data g\n  JOIN countries c ON g.country_id = c.country_id\nWHERE \n  g.year BETWEEN 2010 AND 2020 \n  AND g.unemployment_rate > 10;\n```\nThis query:\n\n1. Joins the `gem_data` table with the `countries` table on the `country_id` column.\n2. Filters the data to include only years between 2010 and 2020.\n3. Applies the unemployment rate filter (>10%).\n4. Selects the desired output columns: `country_name`, `year`, and `unemployment_rate`.\n\n**Step 6: Optional: Consider additional aggregations or calculations**\n\n* If we want to further analyze the high unemployment rates, we might consider aggregating the data by country or calculating additional metrics (e.g., average unemployment rate per country).\n* However, based on the original question, the above query should provide the desired output.",
    "augmentation_type": "cot",
    "original_question": "Find country-years with high unemployment rate (>10%) from GEM data between 2010 and 2020"
  },
  {
    "id": 39,
    "question": "Show government social benefits (percent of GDP) for Germany from 2000 to 2020",
    "ground_truth_sql": "SELECT g.year, g.value AS social_benefits_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Germany'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Social benefits, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2000 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here's a step-by-step breakdown of how to construct the SQL query to answer the question:\n\n**1. Identify the required data:**\nTo answer the question, we need the following data:\n- Government social benefits as a percentage of GDP\n- Time period: 2000 to 2020\n- Country: Germany\n\n**2. Identify the relevant tables and columns:**\nTypically, the required data can be found in the following tables and columns:\n- **gdp** table: contains GDP data for a country over time\n- **gov_spending** table: contains government spending data for a country over time\n- **country** table: contains country-specific data, such as country code and name\n- **time** table: contains time-related data, such as year and quarter\n\n**3. Apply filters or conditions:**\nTo narrow down the data to Germany from 2000 to 2020, we need to apply the following filters:\n- `country_code` = 'DEU' (Germany's ISO code)\n- `year` >= 2000 and `year` <= 2020\n\n**4. Calculate government social benefits as a percentage of GDP:**\nTo calculate the percentage, we need to:\n- Calculate the total government social benefits\n- Calculate the total GDP\n- Divide the total government social benefits by the total GDP and multiply by 100\n\n**5. Construct the SQL query:**\nBased on the above steps, the SQL query can be constructed as follows:\n```sql\nSELECT \n  t.year, \n  (gs.total_social_benefits / gdp.total_gdp) * 100 AS social_benefits_percent_of_gdp\nFROM \n  time t\n  INNER JOIN gdp gdp ON t.year = gdp.year AND gdp.country_code = 'DEU'\n  INNER JOIN gov_spending gs ON gdp.year = gs.year AND gs.country_code = 'DEU'\nWHERE \n  t.year >= 2000 AND t.year <= 2020\n  AND gdp.country_code = 'DEU'\nORDER BY \n  t.year;\n```\nNote that the above query assumes that the `gov_spending` table contains the total social benefits, and the `gdp` table contains the total GDP for each year and country. The actual table and column names may vary depending on the database schema.",
    "augmentation_type": "cot",
    "original_question": "Show government social benefits (percent of GDP) for Germany from 2000 to 2020"
  },
  {
    "id": 40,
    "question": "Show imports merchandise for India from 2010 to 2020",
    "ground_truth_sql": "SELECT g.year, g.value AS imports\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'India'\nAND i.indicator_name = 'Imports Merchandise'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here's a step-by-step breakdown of the SQL query to answer the question:\n\n**1. Identify the required data**\nThe question asks for imports of merchandise for India from 2010 to 2020. We need to gather data on:\n- Import values or quantities\n- Country (India)\n- Year of import (2010-2020)\n\n**2. Choose the relevant tables and columns**\nAssuming we have a database with a structure similar to this:\n- `imports` table: contains data on imports\n  - `country_code` (foreign key referencing the `countries` table)\n  - `year` (year of import)\n  - `value` (import value)\n  - `quantity` (import quantity)\n- `countries` table: contains information on countries\n  - `code` (country code)\n  - `name` (country name)\n\nWe'll use the `imports` table and join it with the `countries` table to get the country name.\n\n**3. Apply filters and conditions**\nTo filter the data, we'll apply the following conditions:\n- `year` between 2010 and 2020 (inclusive)\n- `country_code` matches the code for India\n\n**4. Determine the aggregation or calculation**\nSince the question doesn't specify whether we need to sum, average, or group the data, we'll assume we want to retrieve the total import value and quantity for each year.\n\nHere's the SQL query to answer the question:\n\n```sql\nSELECT \n  i.year, \n  c.name AS country, \n  SUM(i.value) AS total_import_value, \n  SUM(i.quantity) AS total_import_quantity\nFROM \n  imports i\n  JOIN countries c ON i.country_code = c.code\nWHERE \n  i.year BETWEEN 2010 AND 2020 AND\n  c.name = 'India'\nGROUP BY \n  i.year, c.name\nORDER BY \n  i.year;\n```\n\nThis query joins the `imports` table with the `countries` table, filters the data by year and country, aggregates the import values and quantities by year, and returns the results in ascending order by year.",
    "augmentation_type": "cot",
    "original_question": "Show imports merchandise for India from 2010 to 2020"
  },
  {
    "id": 41,
    "question": "List all countries with tax revenue data for 2020",
    "ground_truth_sql": "SELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\nAND g.year = 2020\nORDER BY c.country_name",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "**Step 1: Identify the data needed**\nTo answer the question, we need to retrieve:\n\n* The names of all countries\n* Tax revenue data for 2020\n\n**Step 2: Determine the tables and columns to use**\nBased on the requirements, we'll likely need the following tables and columns:\n\n* A table named `countries` with a column `country_name` or similar\n* A table named `tax_revenue` or `revenue` with columns:\n\t+ `country_name` or similar (to link to the `countries` table)\n\t+ `year` or similar (to filter for 2020)\n\t+ `tax_revenue` or similar (to retrieve the tax revenue data)\n\n**Step 3: Apply filters and conditions**\nWe need to filter the data for the following conditions:\n\n* `year` = 2020 (to retrieve tax revenue data for 2020)\n* Include only countries with tax revenue data (assuming the `tax_revenue` column is not null)\n\n**Step 4: Construct the SQL query**\nHere's a possible SQL query to answer the question:\n\n```sql\nSELECT \n  c.country_name\nFROM \n  countries c\n  JOIN tax_revenue tr ON c.country_name = tr.country_name\nWHERE \n  tr.year = 2020\n  AND tr.tax_revenue IS NOT NULL;\n```\n\nThis query joins the `countries` table with the `tax_revenue` table on the `country_name` column, filters the data for the year 2020 and non-null tax revenue, and selects the country names from the resulting dataset.\n\n**Step 5: Consider additional requirements**\nIf additional requirements arise, such as sorting the results or retrieving aggregate data, we can modify the query accordingly.\n\nFor example, to retrieve the country names in alphabetical order:\n\n```sql\nSELECT \n  c.country_name\nFROM \n  countries c\n  JOIN tax_revenue tr ON c.country_name = tr.country_name\nWHERE \n  tr.year = 2020\n  AND tr.tax_revenue IS NOT NULL\nORDER BY \n  c.country_name ASC;\n```",
    "augmentation_type": "cot",
    "original_question": "List all countries with tax revenue data for 2020"
  },
  {
    "id": 42,
    "question": "List the top 5 countries by number of GEM observations",
    "ground_truth_sql": "SELECT c.country_name, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY obs_count DESC\nLIMIT 5",
    "difficulty": "medium",
    "category": "join_aggregation_limit",
    "reasoning": "**Step-by-Step SQL Query Construction**\n\n1. **Determine the necessary data and tables**:\n\t* The question requires the count of GEM (Good Enough Metrics) observations for each country.\n\t* We assume the data is stored in a database with the following tables:\n\t\t+ `countries` (country information)\n\t\t+ `gem_observations` (GEM observation data)\n2. **Choose the relevant columns**:\n\t* `country_id` or `country_name` from the `countries` table to identify countries\n\t* `country_id` from the `gem_observations` table to link GEM observations to countries\n\t* `id` or `observation_count` from the `gem_observations` table to count the number of GEM observations\n3. **Apply filters or conditions**:\n\t* No specific filters are mentioned in the question, so we'll focus on counting all GEM observations for each country\n4. **Perform aggregations or calculations**:\n\t* We need to count the number of GEM observations for each country using the `COUNT()` aggregation function\n5. **Construct the SQL query**:\n\t* Use a `SELECT` statement to retrieve the required data\n\t* Join the `countries` and `gem_observations` tables on the `country_id` column\n\t* Apply the `COUNT()` aggregation function to count the number of GEM observations for each country\n\t* Use the `TOP 5` clause to retrieve the top 5 countries by number of GEM observations\n\n**SQL Query:**\n```sql\nSELECT TOP 5 c.name, COALESCE(go.observation_count, 0) AS gem_count\nFROM countries c\nLEFT JOIN (\n  SELECT country_id, COUNT(id) AS observation_count\n  FROM gem_observations\n  GROUP BY country_id\n) go ON c.id = go.country_id\nORDER BY go.observation_count DESC;\n```\nThis query joins the `countries` table with a subquery that counts the number of GEM observations for each country. The `LEFT JOIN` ensures that all countries are included, even if they have no GEM observations. The `COALESCE` function returns 0 if the `observation_count` column is null. Finally, the query returns the top 5 countries by number of GEM observations in descending order.",
    "augmentation_type": "cot",
    "original_question": "List the top 5 countries by number of GEM observations"
  },
  {
    "id": 43,
    "question": "Show the CPI Price (% y-o-y) for Japan from 2015 to 2023",
    "ground_truth_sql": "SELECT g.year, g.value AS cpi_yoy\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Japan'\nAND i.indicator_name = 'CPI Price'\nAND i.unit = '% y-o-y, nominal'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here's the step-by-step breakdown to construct the SQL query:\n\n1. **Data Needed**: We need to retrieve the Consumer Price Index (CPI) data for Japan from 2015 to 2023, which includes the CPI price and the year-over-year (y-o-y) percentage change.\n\n2. **Tables/Columns to Use**: Assuming we have a database with economic data, we may have two relevant tables:\n   - `cpi_data`: contains the CPI data for different countries, with columns like `country`, `year`, `cpi_price`, and `cpi_price_yoy`.\n   - `country_info`: contains additional information about countries, including their names and codes. We may need to join this table to get the country name for Japan.\n\n3. **Filters or Conditions to Apply**: We need to filter the data for Japan and the time period 2015-2023. We also want to exclude any rows with missing values.\n\n   - Filter for Japan: `country = 'Japan'`\n   - Filter for years 2015-2023: `year BETWEEN 2015 AND 2023`\n   - Exclude rows with missing values: `cpi_price IS NOT NULL AND cpi_price_yoy IS NOT NULL`\n\n4. **What Aggregations or Calculations Are Needed**: We want to show the CPI Price and the y-o-y percentage change for each year. This means we need to calculate the y-o-y percentage change for the CPI price.\n\n   - To calculate the y-o-y percentage change, we need the CPI price for each year and the previous year's CPI price.\n\n5. **Constructing the SQL Query**:\n   - Start with a SELECT statement to choose the columns we need: `cpi_price` and `cpi_price_yoy`.\n   - Use the FROM clause to specify the table(s) we are using: `cpi_data`.\n   - Apply the filters using the WHERE clause: `country = 'Japan' AND year BETWEEN 2015 AND 2023 AND cpi_price IS NOT NULL AND cpi_price_yoy IS NOT NULL`.\n   - To calculate the y-o-y percentage change, use a subquery or a JOIN to get the previous year's CPI price, and then use the formula: `(current_year_cpi - previous_year_cpi) / previous_year_cpi * 100`.\n\nHere's the sample SQL query:\n\n```sql\nSELECT \n    year,\n    cpi_price,\n    cpi_price_yoy AS cpi_price_yoy_percent\nFROM \n    cpi_data\nWHERE \n    country = 'Japan' AND year BETWEEN 2015 AND 2023 AND cpi_price IS NOT NULL AND cpi_price_yoy IS NOT NULL\n```\n\nHowever, this query does not calculate the y-o-y percentage change. To do that, we need a more complex query with subqueries or JOINs.\n\n```sql\nSELECT \n    d1.year,\n    d1.cpi_price,\n    (d1.cpi_price - d2.cpi_price) / d2.cpi_price * 100 AS cpi_price_yoy_percent\nFROM \n    cpi_data d1\nJOIN \n    cpi_data d2 ON d1.country = d2.country AND d1.year = d2.year + 1\nWHERE \n    d1.country = 'Japan' AND d1.year BETWEEN 2015 AND 2023 AND d1.cpi_price IS NOT NULL AND d2.cpi_price IS NOT NULL\n```\n\nThis query joins the `cpi_data` table with itself on the `country` and `year` columns, but shifts the `year` column by one year using `d2.year + 1`. The y-o-y percentage change is then calculated using the formula.",
    "augmentation_type": "cot",
    "original_question": "Show the CPI Price (% y-o-y) for Japan from 2015 to 2023"
  },
  {
    "id": 44,
    "question": "What is the average expenditure (percent of GDP) for general government across all countries in 2019?",
    "ground_truth_sql": "SELECT AVG(g.value) AS avg_expenditure_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = 'General government'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year = 2019",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "To answer the question, \"What is the average expenditure (percent of GDP) for general government across all countries in 2019?\", we need to follow these steps:\n\n1. **Identify the required data**:\nWe need to extract data on expenditure, GDP, and general government expenditure as a percentage of GDP for each country in 2019.\n\n2. **Determine the necessary tables and columns**:\nWe will require the following tables and columns:\n- `expenditure`: columns for country code, year, and expenditure amount.\n- `gdp`: columns for country code, year, and GDP amount.\n- `government_expenditure`: columns for country code, year, and government expenditure amount.\n\n3. **Apply filters and conditions**:\nTo get the data for 2019, we need to filter the data by year. Additionally, we will filter for general government expenditure to get the required information.\n\n4. **Perform aggregations and calculations**:\nWe need to calculate the average expenditure as a percentage of GDP for general government across all countries in 2019.\n\n**Step-by-Step SQL Query Construction**:\n\n```sql\n-- Step 1: Join the necessary tables\nSELECT \n  e.country_code,\n  e.year,\n  (ge.expenditure / g.gdp) * 100 AS expenditure_percent_gdp\nFROM expenditure e\nJOIN gdp g ON e.country_code = g.country_code AND e.year = g.year\nJOIN government_expenditure ge ON e.country_code = ge.country_code AND e.year = ge.year;\n\n-- Step 2: Filter for 2019 and general government expenditure\nSELECT \n  country_code,\n  year,\n  expenditure_percent_gdp\nFROM (\n  SELECT \n    e.country_code,\n    e.year,\n    (ge.expenditure / g.gdp) * 100 AS expenditure_percent_gdp\n  FROM expenditure e\n  JOIN gdp g ON e.country_code = g.country_code AND e.year = g.year\n  JOIN government_expenditure ge ON e.country_code = ge.country_code AND e.year = ge.year\n) AS subquery\nWHERE year = 2019;\n\n-- Step 3: Group by country and calculate the average expenditure\nSELECT \n  AVG(expenditure_percent_gdp) AS average_expenditure_percent_gdp\nFROM (\n  SELECT \n    country_code,\n    year,\n    (ge.expenditure / g.gdp) * 100 AS expenditure_percent_gdp\n  FROM expenditure e\n  JOIN gdp g ON e.country_code = g.country_code AND e.year = g.year\n  JOIN government_expenditure ge ON e.country_code = ge.country_code AND e.year = ge.year\n) AS subquery\nWHERE year = 2019;\n```\n\n**Final Step: Execute the SQL Query**:\nThe final SQL query to answer the question will be the last step, which calculates the average expenditure as a percentage of GDP for general government across all countries in 2019.\n\n```sql\nSELECT \n  AVG(expenditure_percent_gdp) AS average_expenditure_percent_gdp\nFROM (\n  SELECT \n    country_code,\n    year,\n    (ge.expenditure / g.gdp) * 100 AS expenditure_percent_gdp\n  FROM expenditure e\n  JOIN gdp g ON e.country_code = g.country_code AND e.year = g.year\n  JOIN government_expenditure ge ON e.country_code = ge.country_code AND e.year = ge.year\n) AS subquery\nWHERE year = 2019;\n```",
    "augmentation_type": "cot",
    "original_question": "What is the average expenditure (percent of GDP) for general government across all countries in 2019?"
  },
  {
    "id": 45,
    "question": "Show the stock market index for the United Kingdom from 2015 to 2023",
    "ground_truth_sql": "SELECT g.year, g.value AS stock_market\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'United Kingdom'\nAND i.indicator_name = 'Stock Markets'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "**Breaking down the SQL query step-by-step**\n\n**1. Identify the requirements and data needed**\n\n- We need to show the stock market index for the United Kingdom.\n- The time period is from 2015 to 2023.\n- We'll likely need a table with stock market index data and another table with country information.\n\n**2. Choose the relevant tables and columns**\n\n- Table name: `stock_market_index` (or similar)\n  - Columns: `id`, `date`, `country`, `index_value`\n- Table name: `countries` (or similar)\n  - Columns: `id`, `name`, `code`\n\n**3. Apply filters and conditions**\n\n- Filter by country: `country` = 'United Kingdom'\n- Filter by date range: `date` between '2015-01-01' and '2023-12-31'\n\n**4. Determine aggregations or calculations needed**\n\n- Since we're showing a stock market index, we likely want to display the average or latest index value for each year.\n\n**5. Construct the SQL query**\n\n```sql\nSELECT \n  EXTRACT(YEAR FROM date) AS year,\n  AVG(index_value) AS average_index_value\nFROM \n  stock_market_index\nWHERE \n  country = 'United Kingdom'\n  AND date BETWEEN '2015-01-01' AND '2023-12-31'\nGROUP BY \n  EXTRACT(YEAR FROM date)\nORDER BY \n  year;\n```\n\nThis query will return the average stock market index value for the United Kingdom for each year from 2015 to 2023.\n\n**6. Consider any additional requirements**\n\n- If the query needs to show the latest index value for each year instead of the average, replace `AVG(index_value)` with `MAX(index_value)`.\n\nNote: The actual table names and column names may vary depending on the specific database schema.",
    "augmentation_type": "cot",
    "original_question": "Show the stock market index for the United Kingdom from 2015 to 2023"
  },
  {
    "id": 46,
    "question": "Show exports merchandise (current US$ millions) for Brazil from 2010 to 2020",
    "ground_truth_sql": "SELECT g.year, g.value AS exports_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND i.indicator_name = 'Exports Merchandise'\nAND i.unit LIKE '%current US$%'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "To construct the SQL query, follow these step-by-step instructions:\n\n1. **Identify the required data**: \n   - The question requires data on exports merchandise, which is typically stored in a database related to trade statistics.\n   - We need to retrieve data for Brazil and the period from 2010 to 2020.\n\n2. **Determine which tables/columns to use**:\n   - The table likely to contain the relevant data is a trade statistics table, which may be named `trade_stats` or something similar.\n   - The columns needed are:\n     - `country_name` or `country_code` to identify Brazil\n     - `year` or `date` to filter by the desired period\n     - `exports_merchandise` to display the current US$ millions\n     - `currency_code` to ensure the data is in US$ millions\n\n3. **Apply filters or conditions**:\n   - Filter by `country_name` or `country_code` to include only Brazil (`country_name = 'Brazil'` or `country_code = 'BRA'`)\n   - Filter by `year` or `date` to include only the period from 2010 to 2020 (`year BETWEEN 2010 AND 2020`)\n   - Ensure the data is in US$ millions by filtering by `currency_code` (`currency_code = 'USD'`)\n\n4. **Apply aggregations or calculations**:\n   - Since we want to display the values for each year, we can use the `GROUP BY` clause with the `year` column.\n   - To display the total exports merchandise for each year, we can use the `SUM` aggregation function with the `exports_merchandise` column.\n\n5. **Construct the SQL query**:\n   ```sql\nSELECT \n  year,\n  SUM(exports_merchandise) AS exports_merchandise_curr_usd_millions\nFROM \n  trade_stats\nWHERE \n  country_name = 'Brazil' \n  AND currency_code = 'USD' \n  AND year BETWEEN 2010 AND 2020\nGROUP BY \n  year\nORDER BY \n  year;\n```\n\nThis SQL query will retrieve the total exports merchandise for Brazil in US$ millions for each year from 2010 to 2020.",
    "augmentation_type": "cot",
    "original_question": "Show exports merchandise (current US$ millions) for Brazil from 2010 to 2020"
  },
  {
    "id": 47,
    "question": "List all countries that have data for both GFS and GEM",
    "ground_truth_sql": "SELECT DISTINCT c.country_name\nFROM countries c\nWHERE c.country_id IN (SELECT DISTINCT country_id FROM gfs_observations)\nAND c.country_id IN (SELECT DISTINCT country_id FROM gem_observations)\nORDER BY c.country_name",
    "difficulty": "medium",
    "category": "subquery",
    "reasoning": "**Step 1: Identify the tables and columns needed**\nTo answer this question, we need to identify the tables that contain data for GFS and GEM. Let's assume we have two tables: `gfs_data` and `gem_data`. We will also need the `country` table to get the country names.\n\n**Step 2: Determine the necessary columns**\nWe need to get the country names that have data for both GFS and GEM. We will select the `country_name` column from the `country` table.\n\n**Step 3: Find countries with data for GFS**\nWe need to find the countries that have data for GFS. We will use the `gfs_data` table and select the distinct `country_id` from this table.\n\n**Step 4: Find countries with data for GEM**\nWe need to find the countries that have data for GEM. We will use the `gem_data` table and select the distinct `country_id` from this table.\n\n**Step 5: Find the intersection of GFS and GEM countries**\nTo find the countries that have data for both GFS and GEM, we need to find the intersection of the `country_id` from the previous steps.\n\n**Step 6: Join the `country` table to get the country names**\nWe will join the `country` table with the intersected `country_id` to get the country names.\n\n**Step 7: Write the SQL query**\nHere is the SQL query that follows the above steps:\n\n```sql\nSELECT c.country_name\nFROM country c\nJOIN (\n  SELECT DISTINCT country_id\n  FROM gfs_data\n  INTERSECT\n  SELECT DISTINCT country_id\n  FROM gem_data\n) AS intersection ON c.country_id = intersection.country_id;\n```\n\nThis query will list all countries that have data for both GFS and GEM. Note that this query assumes that the `country_id` in the `gfs_data` and `gem_data` tables matches the `country_id` in the `country` table. If the column names are different, you will need to adjust the query accordingly.",
    "augmentation_type": "cot",
    "original_question": "List all countries that have data for both GFS and GEM"
  },
  {
    "id": 48,
    "question": "Show the unemployment rate for Germany for all available years",
    "ground_truth_sql": "SELECT g.year, g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Germany'\nAND i.indicator_name = 'Unemployment Rate'\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "To answer the question \"Show the unemployment rate for Germany for all available years,\" we'll follow these steps:\n\n**Step 1: Identify the necessary data and tables**\nWe need data on unemployment rates and the corresponding population of Germany. Typically, this data can be found in a table like `employment_data` or `labour_market_data`, which might contain columns like `country`, `year`, `unemployment_rate`, and `population`.\n\n**Step 2: Specify the columns and tables to use**\nLet's assume the table name is `labour_market_data` and the relevant columns are:\n\n- `country`: String column containing the country name\n- `year`: Integer column representing the year\n- `unemployment_rate`: Decimal column with the unemployment rate\n- `population`: Decimal column with the total population of the country\n\n**Step 3: Apply filters and conditions**\nTo focus on Germany, we'll add a filter on the `country` column:\n\n- `country = 'Germany'`\n\n**Step 4: Determine the necessary aggregations or calculations**\nSince we want the unemployment rate, we don't need any aggregations. However, to calculate the unemployment rate, we'll use the formula: `unemployment_rate / population * 100`. We'll store this in a new column.\n\n**Step 5: Combine the steps into a SQL query**\nHere's the resulting SQL query:\n\n```sql\nSELECT \n  year,\n  (unemployment_rate / population) * 100 AS unemployment_rate_percentage\nFROM \n  labour_market_data\nWHERE \n  country = 'Germany';\n```\n\nThis query will return a list of years with the unemployment rate percentage for Germany. \n\nNote: In a real-world scenario, you might need to perform additional data cleaning, handle missing values, and consider the source of the data to ensure its accuracy.",
    "augmentation_type": "cot",
    "original_question": "Show the unemployment rate for Germany for all available years"
  },
  {
    "id": 49,
    "question": "Using GEM CPI data, find countries where inflation (CPI % year-over-year) exceeded 10% in any year between 2015 and 2023",
    "ground_truth_sql": "SELECT DISTINCT\n    c.country_name,\n    g.year,\n    g.value AS cpi_yoy_pct\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'CPI Price'\n    AND i.unit = '% y-o-y, nominal'\n    AND g.year BETWEEN 2015 AND 2023\n    AND g.value > 10\nORDER BY g.value DESC",
    "difficulty": "medium",
    "category": "filtering",
    "reasoning": "To construct the SQL query, follow these steps:\n\n**1. Identify required data and tables:**\n- The data needed is the Country, Year, and CPI % year-over-year values from the GEM CPI dataset.\n- The tables/columns to use are likely `cpi_data` (assuming it contains the necessary columns) or similar, with columns:\n  - `country`\n  - `year`\n  - `cpi_year_over_year` (the inflation rate)\n\n**2. Apply filters and conditions:**\n- Filter the data to only include years between 2015 and 2023.\n- Filter the data to only include countries where the CPI % year-over-year exceeded 10% in any year.\n\n**3. Determine the aggregation or calculation needed:**\n- No aggregation is needed; we want to identify individual countries meeting the condition in any year.\n- However, we'll use a `WHERE` clause to filter the data based on the condition.\n\n**4. Construct the SQL query:**\n```sql\nSELECT DISTINCT country\nFROM cpi_data\nWHERE year BETWEEN 2015 AND 2023\nAND cpi_year_over_year > 10;\n```\nExplanation:\n- `SELECT DISTINCT country`: Selects only unique country names.\n- `FROM cpi_data`: Specifies the table containing the data.\n- `WHERE year BETWEEN 2015 AND 2023`: Filters the data to include only years between 2015 and 2023.\n- `AND cpi_year_over_year > 10`: Filters the data to include only countries where the CPI % year-over-year exceeded 10%.\n\nThis query will return the list of countries that met the condition in any year between 2015 and 2023.",
    "augmentation_type": "cot",
    "original_question": "Using GEM CPI data, find countries where inflation (CPI % year-over-year) exceeded 10% in any year between 2015 and 2023"
  },
  {
    "id": 50,
    "question": "Count GFS observations per country per year (limited to 2020)",
    "ground_truth_sql": "SELECT c.country_name, g.year, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE g.year = 2020\nGROUP BY c.country_name, g.year\nORDER BY obs_count DESC\nLIMIT 20",
    "difficulty": "medium",
    "category": "join_aggregation",
    "reasoning": "Here's a step-by-step guide to construct the SQL query:\n\n**1. Identify the data needed:**\nWe need to count the number of GFS (Global Forecast System) observations per country per year. This implies we need data on:\n- GFS observations\n- Country information\n- Yearly information\n\n**2. Determine the tables and columns to use:**\nBased on the data needed, we can assume the following tables and columns exist:\n- **gfs_observations**: This table contains GFS observation data.\n  - **country_id** (foreign key referencing the country table)\n  - **year**\n  - **observation_id** (unique identifier for each observation)\n- **countries**: This table contains country information.\n  - **country_id** (unique identifier for each country)\n  - **country_name**\n- **years**: This table contains yearly information. This might be a separate table or a column in another table (e.g., gfs_observations).\n\nHowever, it would be more logical to assume the years are part of the gfs_observations table as they are observations made in a specific year.\n\n**3. Apply filters or conditions:**\nTo limit the data to 2020, we need to apply a filter on the year column:\n- **year** = 2020\n\nAdditionally, we should limit the data to GFS observations:\n- **type** = 'GFS observation' (assuming a type column exists in the gfs_observations table)\n\n**4. Determine aggregations or calculations:**\nWe need to count the number of GFS observations per country per year. This can be done using the COUNT function in SQL:\n- **COUNT(1)** or **COUNT(*)** (both count the number of rows, but COUNT(1) can be more efficient)\n\nHere's the SQL query:\n\n```sql\nSELECT \n  c.country_name, \n  g.year, \n  COUNT(g.observation_id) AS observation_count\nFROM \n  gfs_observations g\n  JOIN countries c ON g.country_id = c.country_id\nWHERE \n  g.year = 2020 \n  AND g.type = 'GFS observation'\nGROUP BY \n  c.country_name, \n  g.year\nORDER BY \n  c.country_name, \n  g.year;\n```\n\nThis query will return the number of GFS observations per country per year in 2020.",
    "augmentation_type": "cot",
    "original_question": "Count GFS observations per country per year (limited to 2020)"
  },
  {
    "id": 51,
    "question": "Count the number of countries with GFS data for each year",
    "ground_truth_sql": "SELECT year, COUNT(DISTINCT country_id) AS country_count\nFROM gfs_observations\nGROUP BY year\nORDER BY year",
    "difficulty": "medium",
    "category": "aggregation",
    "reasoning": "Here's a step-by-step breakdown of how to construct the SQL query to answer the question:\n\n**Step 1: Identify the necessary data and tables**\n\n* The question requires information about countries and GFS (General Fisheries Statistical Area) data.\n* We need to access the tables that store this information:\n\t+ `countries` table: contains information about countries.\n\t+ `gfs_data` table: contains information about GFS data, which is specific to each country and year.\n\n**Step 2: Determine the necessary columns**\n\n* We need to count the number of countries with GFS data for each year.\n* The required columns are:\n\t+ `country_id` or `country_name` from the `countries` table to identify the countries.\n\t+ `year` from the `gfs_data` table to determine the year.\n\t+ A column to indicate the presence of GFS data, such as `has_gfs_data` or a similar indicator.\n\n**Step 3: Apply filters or conditions**\n\n* We need to filter the data to include only countries with GFS data for each year.\n* The condition to apply is: `has_gfs_data = 1` (assuming the existence of a `has_gfs_data` column in the `gfs_data` table).\n\n**Step 4: Perform aggregations or calculations**\n\n* We need to count the number of countries with GFS data for each year.\n* The required aggregation is: `COUNT(DISTINCT country_id)` or `COUNT(DISTINCT country_name)` to count the distinct countries.\n\n**Step 5: Construct the SQL query**\n\nHere's the SQL query that combines the previous steps:\n\n```sql\nSELECT \n  EXTRACT(YEAR FROM gfs_data.date) AS year,\n  COUNT(DISTINCT c.country_name) AS num_countries_with_gfs_data\nFROM \n  countries c\n  JOIN gfs_data gd ON c.country_id = gd.country_id\nGROUP BY \n  EXTRACT(YEAR FROM gfs_data.date)\nORDER BY \n  year;\n```\n\nNote: The `date` column in the `gfs_data` table is assumed to store the date when the GFS data was recorded, and we use the `EXTRACT` function to extract the year from the date. If the `year` column exists in the `gfs_data` table, we can simply use that column instead.",
    "augmentation_type": "cot",
    "original_question": "Count the number of countries with GFS data for each year"
  },
  {
    "id": 52,
    "question": "Count GFS observations by transformation type",
    "ground_truth_sql": "SELECT transformation, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY transformation\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "aggregation",
    "reasoning": "To answer the question \"Count GFS (Global Firepower Statistics) observations by transformation type,\" I'll break down the steps as follows:\n\n**Step 1: Identify the Data Needed**\nThe question requires data related to GFS observations and their transformation types. This implies we need tables containing observation data and possibly a table for transformation types.\n\n**Step 2: Choose Relevant Tables and Columns**\nAssuming we have the following tables:\n\n- `observations` table with columns: `id`, `observation_type`, `transformation_type`, etc.\n- `transformation_types` table with columns: `id`, `name`, `description`, etc.\n\nWe'll use the `observations` table to get the observation data and the `transformation_types` table to get the transformation types.\n\n**Step 3: Apply Filters or Conditions (if necessary)**\nSince the problem statement doesn't specify any filters or conditions, we can proceed without applying any filters. However, if we were to filter for specific observation types or a particular date range, we would add conditions to the `WHERE` clause.\n\n**Step 4: Determine the Aggregations or Calculations Needed**\nThe question asks to \"Count GFS observations by transformation type,\" which means we need to group the observations by their transformation types and then count the number of observations for each group.\n\n**Step 5: Construct the SQL Query**\nWith the above steps in mind, the SQL query would look like this:\n\n```sql\nSELECT \n    tt.name AS transformation_type,\n    COUNT(o.id) AS observation_count\nFROM \n    observations o\nJOIN \n    transformation_types tt ON o.transformation_type = tt.id\nGROUP BY \n    tt.name\nORDER BY \n    tt.name;\n```\n\nThis query does the following:\n\n- Joins the `observations` table with the `transformation_types` table on the `transformation_type` column.\n- Groups the joined data by the `transformation_type` (which is actually the `name` column in the `transformation_types` table).\n- Counts the number of observations for each group using the `COUNT` aggregation function.\n- Orders the results by the `transformation_type` (or `name`) for easier viewing.",
    "augmentation_type": "cot",
    "original_question": "Count GFS observations by transformation type"
  },
  {
    "id": 53,
    "question": "Calculate average GDP at market prices (constant 2010 US$) by country for 2015-2020, and rank the top 10 countries",
    "ground_truth_sql": "SELECT\n    c.country_name,\n    AVG(g.value) AS avg_gdp_millions,\n    COUNT(*) AS years_of_data\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2015 AND 2020\nGROUP BY c.country_name\nORDER BY avg_gdp_millions DESC\nLIMIT 10",
    "difficulty": "medium",
    "category": "aggregation_ranking",
    "reasoning": "**Step 1: Identify the necessary data**\n\nTo answer this question, we need data on GDP at market prices (constant 2010 US$) for the years 2015-2020, broken down by country.\n\n**Step 2: Determine the tables and columns to use**\n\nBased on the required data, we can expect to use a table named `gdp_data` with the following structure:\n- `country_name` (string): the name of the country\n- `year` (integer): the year of the data\n- `gdp_constant_2010_usd` (numeric): the GDP at market prices (constant 2010 US$)\n\n**Step 3: Apply filters or conditions**\n\nWe need to filter the data for the years 2015-2020.\n- Filter the data where `year` is between 2015 and 2020 (inclusive).\n\n**Step 4: Select the required columns**\n\nWe need to select the `country_name` and `gdp_constant_2010_usd` columns from the `gdp_data` table.\n\n**Step 5: Perform aggregations or calculations**\n\nTo calculate the average GDP at market prices (constant 2010 US$) by country, we need to:\n- Group the filtered data by `country_name`\n- Calculate the average `gdp_constant_2010_usd` for each group\n\n**Step 6: Rank the top 10 countries**\n\nTo rank the top 10 countries by average GDP at market prices (constant 2010 US$), we need to:\n- Use the `RANK()` function to assign a rank to each country based on its average GDP\n- Select the top 10 countries with the highest average GDP\n\n**Step 7: Construct the SQL query**\n\nHere's the SQL query based on the steps above:\n\n```sql\nSELECT \n    country_name, \n    AVG(gdp_constant_2010_usd) AS avg_gdp\nFROM \n    gdp_data\nWHERE \n    year BETWEEN 2015 AND 2020\nGROUP BY \n    country_name\nORDER BY \n    avg_gdp DESC\nLIMIT 10;\n```\n\nHowever, the `RANK()` function is not used above as its syntax may vary depending on the database being used. Instead, we directly order the results by the average GDP in descending order and use the `LIMIT` clause to get the top 10 countries.\n\n**Step 8: Test and refine the query**\n\nBefore using this query in a production environment, test it with a sample dataset to ensure it produces the correct results. Refine the query as needed to handle any edge cases or optimize performance.",
    "augmentation_type": "cot",
    "original_question": "Calculate average GDP at market prices (constant 2010 US$) by country for 2015-2020, and rank the top 10 countries"
  },
  {
    "id": 54,
    "question": "Show government revenue (percent of GDP) for Australia from 2010 to 2020",
    "ground_truth_sql": "SELECT g.year, g.value AS revenue_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here's the step-by-step process to construct the SQL query:\n\n**1. Identify the required data:**\nWe need to retrieve government revenue (in percentage of GDP) for Australia over the period from 2010 to 2020. This implies we'll require data on:\n- Government revenue\n- GDP\n- Time period (year)\n- Country (Australia)\n\n**2. Determine the relevant tables/columns:**\nWe'll likely need to use the following tables:\n- **Revenue** table: containing government revenue data\n- **GDP** table: containing GDP data\n- **Country** table: containing country information (including Australia)\n- **TimeSeries** table: containing time period data (year)\n\n**3. Apply filters or conditions:**\nWe need to filter the data by:\n- Country: Australia\n- Time period: between 2010 and 2020 (inclusive)\n- Possibly, other relevant conditions (e.g., economic indicators)\n\n**4. Determine the required aggregations or calculations:**\nWe'll need to:\n- Calculate the percentage of GDP for government revenue\n- Group the data by year (to show the revenue as a percentage of GDP for each year)\n\n**5. Construct the SQL query:**\nBased on the above steps, the SQL query could be:\n```sql\nSELECT \n    t.year,\n    (r.revenue / g.gdp) * 100 AS gov_rev_percent_of_gdp\nFROM \n    Revenue r\nJOIN \n    GDP g ON r.country_id = g.country_id AND r.year = g.year\nJOIN \n    Country c ON g.country_id = c.country_id\nJOIN \n    TimeSeries t ON g.year = t.year\nWHERE \n    c.country_name = 'Australia'\n    AND t.year BETWEEN 2010 AND 2020;\n```\n**6. Refine the query (if necessary):**\nDepending on the actual data structure and availability, additional joins or subqueries might be required. This query would need to be adapted based on the actual database schema.",
    "augmentation_type": "cot",
    "original_question": "Show government revenue (percent of GDP) for Australia from 2010 to 2020"
  },
  {
    "id": 55,
    "question": "What is the sum of all GFS observation values for the year 2020?",
    "ground_truth_sql": "SELECT SUM(value) AS total_value\nFROM gfs_observations\nWHERE year = 2020",
    "difficulty": "medium",
    "category": "aggregation",
    "reasoning": "Here are the step-by-step instructions to construct the SQL query for the given question:\n\n1. **Identify the data needed**: We need the observation values for GFS (Global Forecast System) for the year 2020. This likely involves data related to GFS observations, their values, and the dates associated with these observations.\n\n2. **Determine the relevant tables and columns**: \n   - **Table 1:** GFS observations (e.g., 'gfs_observations')\n   - **Columns:**\n     - 'gfs_observation_value' (or similar column name for the GFS observation value)\n     - 'observation_date' (or similar column name for the date associated with the observation)\n     - 'year' (or a more complex date-related column to extract the year from 'observation_date')\n\n3. **Apply filters or conditions**:\n   - Filter the data for the year 2020 by using the 'observation_date' column in combination with the 'year' column. This could involve using a date function (e.g., 'YEAR(observation_date)') to extract the year from the date and then comparing it to 2020.\n\n4. **Determine the aggregation or calculation needed**: Since we want the sum of all GFS observation values for the year 2020, we need to perform a **SUM** aggregation on the 'gfs_observation_value' column.\n\n5. **Construct the SQL query**: Combine the steps above into a single SQL query.\n```sql\nSELECT \n  SUM(gfs_observation_value) AS total_gfs_value\nFROM \n  gfs_observations\nWHERE \n  YEAR(observation_date) = 2020;\n```\n\n6. **Execute the query**: Run the SQL query to retrieve the sum of all GFS observation values for the year 2020.",
    "augmentation_type": "cot",
    "original_question": "What is the sum of all GFS observation values for the year 2020?"
  },
  {
    "id": 56,
    "question": "Show the total reserves for China from 2010 to 2020",
    "ground_truth_sql": "SELECT g.year, g.value AS total_reserves\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'China'\nAND i.indicator_name = 'Total Reserves'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "reasoning": "Here are the step-by-step instructions to construct an SQL query to answer the question:\n\n1. **Determine the required data**: To answer the question, we need data on reserves for China across the years 2010 to 2020. We likely need data related to international reserves, foreign exchange, or economic indicators.\n\n2. **Identify the relevant tables and columns**: Based on the data needed, we should search for a table(s) that contains the following columns:\n   - Country or region name\n   - Year or date column\n   - Reserve or economic indicator column (e.g., foreign exchange reserves)\n\n   Let's assume the relevant table is named 'financial_data' and it contains the following columns:\n   - country_name (varchar)\n   - year (int)\n   - foreign_exchange_reserves (int)\n\n3. **Apply filters or conditions**: To answer the question, we need to filter the data for China and the years 2010 to 2020. We can use the following conditions:\n   - country_name = 'China'\n   - year >= 2010\n   - year <= 2020\n\n4. **Perform aggregations or calculations**: Since we want to show the total reserves for China, we don't need to perform any complex calculations. We simply need to sum the foreign exchange reserves for each year.\n\n5. **Construct the SQL query**: Using the above steps, we can construct the following SQL query:\n   ```sql\nSELECT \n  year, \n  SUM(foreign_exchange_reserves) AS total_reserves\nFROM \n  financial_data\nWHERE \n  country_name = 'China'\n  AND year BETWEEN 2010 AND 2020\nGROUP BY \n  year;\n```\n\nThis query will return a result set with two columns: year and total_reserves. The total_reserves column will contain the sum of foreign exchange reserves for each year.",
    "augmentation_type": "cot",
    "original_question": "Show the total reserves for China from 2010 to 2020"
  },
  {
    "id": 57,
    "question": "Find countries with the highest volatility (standard deviation) in unemployment rate from 2010 to 2020",
    "ground_truth_sql": "SELECT c.country_name, \n       AVG(g.value) AS avg_unemployment,\n       COUNT(*) AS data_points,\n       (SUM(g.value * g.value) / COUNT(*)) - (AVG(g.value) * AVG(g.value)) AS variance\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nAND g.year BETWEEN 2010 AND 2020\nGROUP BY c.country_name\nHAVING COUNT(*) >= 5\nORDER BY variance DESC\nLIMIT 10",
    "difficulty": "hard",
    "category": "statistical",
    "reasoning": "To answer the question, follow these steps:\n\n1. **Determine the required data**: The query needs data on unemployment rates for different countries from 2010 to 2020.\n\n2. **Identify the relevant tables/columns**:\n   - **Table 1:** A table containing country information (e.g., country names, codes), which is likely a dimension table.\n   - **Table 2:** A fact table containing economic data (e.g., unemployment rates) with the following columns:\n     - **Country Code**: Foreign key referencing the country dimension table.\n     - **Year**: The year for which the economic data is recorded.\n     - **Unemployment Rate**: The rate of unemployment in the country for that year.\n\n3. **Apply filters or conditions**:\n   - **Time period**: Filter the data to include only years from 2010 to 2020.\n   - **Country filter**: Assuming the requirement is to consider all countries, no further filter is needed.\n\n4. **Calculate standard deviation for each country**:\n   - To find the highest standard deviation, you need to calculate the standard deviation of unemployment rates for each country over the given time period.\n\n5. **Rank countries by standard deviation**:\n   - After calculating the standard deviation, you will need to rank the countries by their standard deviation in descending order to find the ones with the highest volatility.\n\n6. **Select the top countries**:\n   - You will need to select the top N countries (where N is a parameter or a fixed number) based on their standard deviation.\n\nThe SQL query to answer this question can be broken down into these steps:\n\n```sql\n-- Step 1: Select the required columns from the fact table and join it with the dimension table for country information\nSELECT \n  c.country_name, \n  c.country_code, \n  AVG(e.unemployment_rate) AS average_unemployment_rate, \n  STDEV(e.unemployment_rate) AS unemployment_rate_std_dev\nFROM \n  table2 e\nJOIN \n  table1 c ON e.country_code = c.country_code\nWHERE \n  e.year BETWEEN 2010 AND 2020\nGROUP BY \n  c.country_code, c.country_name\nORDER BY \n  unemployment_rate_std_dev DESC;\n\n-- Step 2: Rank the countries by standard deviation\nSELECT \n  country_name, \n  country_code, \n  average_unemployment_rate, \n  unemployment_rate_std_dev,\n  DENSE_RANK() OVER (ORDER BY unemployment_rate_std_dev DESC) AS volatility_rank\nFROM \n  (\n    -- The subquery is the same as above\n  ) AS subquery;\n\n-- Step 3: Select the top N countries\nSELECT \n  country_name, \n  country_code, \n  average_unemployment_rate, \n  unemployment_rate_std_dev\nFROM \n  (\n    -- The subquery is the same as above\n  ) AS subquery\nWHERE \n  volatility_rank <= N;\n```\n\nNote: Replace `table1` and `table2` with the actual names of your dimension and fact tables. Also, the variable `N` should be replaced with the desired number of countries to return.",
    "augmentation_type": "cot",
    "original_question": "Find countries with the highest volatility (standard deviation) in unemployment rate from 2010 to 2020"
  },
  {
    "id": 58,
    "question": "Calculate the cumulative sum of tax revenue over years for Australia",
    "ground_truth_sql": "WITH yearly_tax AS (\n    SELECT g.year, g.value AS tax_revenue\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'Australia'\n    AND s.sector_name = 'General government'\n    AND i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\n    AND g.transformation = 'Percent of GDP'\n)\nSELECT year, tax_revenue,\n       SUM(tax_revenue) OVER (ORDER BY year) AS cumulative_tax\nFROM yearly_tax\nORDER BY year",
    "difficulty": "hard",
    "category": "window_function",
    "reasoning": "**Step 1: Identify the data needed**\n\nTo calculate the cumulative sum of tax revenue over years for Australia, we need to gather data on tax revenue by year and country. This data is likely stored in a financial database, possibly in a table named `tax_revenue` or `financial_data`.\n\n**Step 2: Identify the relevant tables and columns**\n\nWe'll likely need the following tables and columns:\n\n* `tax_revenue` or `financial_data` table with the following columns:\n  - `year`: the year for which the tax revenue is reported\n  - `country`: the country where the tax revenue is reported\n  - `tax_revenue`: the amount of tax revenue collected\n\n**Step 3: Apply filters or conditions**\n\nTo focus on Australia, we'll filter the data by country:\n\n* Filter the `tax_revenue` or `financial_data` table to include only rows where `country` is 'Australia'.\n\n**Step 4: Order the data by year**\n\nTo calculate the cumulative sum, we need to order the data by year:\n\n* Order the filtered data by `year` in ascending order.\n\n**Step 5: Calculate the cumulative sum**\n\nTo calculate the cumulative sum of tax revenue, we can use the following SQL query:\n\n```sql\nSELECT \n  year,\n  country,\n  tax_revenue,\n  SUM(tax_revenue) OVER (ORDER BY year ROWS UNBOUNDED PRECEDING) AS cumulative_tax_revenue\nFROM \n  tax_revenue\nWHERE \n  country = 'Australia'\nORDER BY \n  year;\n```\n\nThis query uses the `SUM` aggregation function with an `OVER` clause to calculate the cumulative sum of tax revenue. The `ORDER BY` clause specifies that the data should be ordered by year, and the `ROWS UNBOUNDED PRECEDING` clause specifies that the cumulative sum should include all previous rows.\n\nAlternatively, if your SQL dialect does not support window functions, you can use a self-join or a variable to calculate the cumulative sum:\n\n```sql\nSELECT \n  yr.year,\n  yr.tax_revenue,\n  (SELECT SUM(tr.tax_revenue) FROM tax_revenue tr WHERE tr.year <= yr.year) AS cumulative_tax_revenue\nFROM \n  tax_revenue yr\nWHERE \n  yr.country = 'Australia'\nORDER BY \n  yr.year;\n```\n\nThis query uses a subquery to calculate the cumulative sum of tax revenue for each year.",
    "augmentation_type": "cot",
    "original_question": "Calculate the cumulative sum of tax revenue over years for Australia"
  },
  {
    "id": 59,
    "question": "Compare government expenditure between central and local government for Brazil over 2015-2022",
    "ground_truth_sql": "SELECT g.year,\n       SUM(CASE WHEN s.sector_name = 'Central government including social security' THEN g.value ELSE 0 END) AS central_govt,\n       SUM(CASE WHEN s.sector_name = 'Local Government' THEN g.value ELSE 0 END) AS local_govt,\n       SUM(CASE WHEN s.sector_name = 'Central government including social security' THEN g.value ELSE 0 END) -\n       SUM(CASE WHEN s.sector_name = 'Local Government' THEN g.value ELSE 0 END) AS difference\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2015 AND 2022\nGROUP BY g.year\nORDER BY g.year",
    "difficulty": "hard",
    "category": "cross_sector_comparison",
    "reasoning": "To answer the question, we'll follow these steps:\n\n**1. Identify the required data:**\nWe need to gather data on government expenditure for both central and local governments in Brazil for the years 2015-2022. This data likely resides in a database with information on government finances.\n\n**2. Choose relevant tables and columns:**\nAssuming a database structure similar to the following:\n\n- `government_finances` table with columns:\n  - `id` (unique identifier)\n  - `year`\n  - `government_type` (central, local, etc.)\n  - `expenditure` (amount of expenditure)\n  - `country` (name of the country)\n  - `location` (name of the location within the country)\n\n- We can use the `government_finances` table with the following columns:\n  - `year`\n  - `government_type`\n  - `expenditure`\n  - `country` (filtering for Brazil)\n\n**3. Apply filters and conditions:**\nTo answer the question, we need to filter the data for Brazil and the specified time period (2015-2022). We can apply the following conditions:\n\n- `country` = 'Brazil'\n- `year` >= 2015 AND `year` <= 2022\n\n**4. Apply aggregations and calculations:**\nTo compare government expenditure between central and local governments, we can apply the following aggregations:\n\n- Group the data by `year` and `government_type`\n- Calculate the total `expenditure` for each group\n\n**5. Construct the SQL query:**\nBased on the above steps, the SQL query will look like this:\n\n```sql\nSELECT \n  year,\n  government_type,\n  SUM(expenditure) AS total_expenditure\nFROM \n  government_finances\nWHERE \n  country = 'Brazil'\n  AND year >= 2015\n  AND year <= 2022\nGROUP BY \n  year,\n  government_type\nORDER BY \n  year,\n  government_type;\n```\n\nThis query will return the total expenditure for central and local governments in Brazil for each year from 2015 to 2022.",
    "augmentation_type": "cot",
    "original_question": "Compare government expenditure between central and local government for Brazil over 2015-2022"
  },
  {
    "id": 60,
    "question": "Rank countries by their average GDP growth from 2015 to 2020, showing only the top 15",
    "ground_truth_sql": "WITH gdp_by_year AS (\n    SELECT c.country_name, g.year, g.value AS gdp\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2014 AND 2020\n),\ngrowth_rates AS (\n    SELECT country_name, year,\n           (gdp - LAG(gdp) OVER (PARTITION BY country_name ORDER BY year)) / \n           LAG(gdp) OVER (PARTITION BY country_name ORDER BY year) * 100 AS growth_rate\n    FROM gdp_by_year\n)\nSELECT country_name, AVG(growth_rate) AS avg_growth_rate,\n       RANK() OVER (ORDER BY AVG(growth_rate) DESC) AS rank\nFROM growth_rates\nWHERE growth_rate IS NOT NULL\nGROUP BY country_name\nORDER BY avg_growth_rate DESC\nLIMIT 15",
    "difficulty": "hard",
    "category": "window_function",
    "reasoning": "To answer the question, we need to rank countries by their average GDP growth from 2015 to 2020, showing only the top 15. Here's a step-by-step breakdown:\n\n1. **Identify the required data**:\n\t* We need data on countries and their GDP growth from 2015 to 2020.\n\t* The data should be in a format that allows us to calculate the average GDP growth for each country.\n\n2. **Choose the relevant tables and columns**:\n\t* We likely have a table called `gdp_data` or `economy` that contains GDP data for various countries over different years.\n\t* The table should have columns for:\n\t\t+ `country`: the name of the country\n\t\t+ `year`: the year of the GDP data\n\t\t+ `gdp`: the GDP value for the country in that year\n\t* We may also need a table called `country_info` that contains additional information about each country.\n\n3. **Apply filters or conditions**:\n\t* We only need data from 2015 to 2020, so we'll filter the data to include only these years.\n\t* We'll also want to exclude any countries with missing data for these years.\n\n4. **Calculate the average GDP growth**:\n\t* To calculate the average GDP growth for each country, we'll need to perform a calculation on the available data.\n\t* We can use the formula: (GDP in 2020 - GDP in 2015) / GDP in 2015.\n\n5. **Rank the countries by average GDP growth**:\n\t* To get the top 15 countries by average GDP growth, we'll use a ranking function (e.g., ROW_NUMBER() or RANK()) to assign a ranking to each country based on its average GDP growth.\n\n6. **Construct the SQL query**:\n\t* Here's a possible query to answer the question:\n```sql\nSELECT \n  country,\n  AVG(gdp_2020 - gdp_2015) / gdp_2015 AS average_gdp_growth\nFROM \n  (\n    SELECT \n      country,\n      SUM(CASE WHEN year = 2020 THEN gdp END) / SUM(CASE WHEN year = 2015 THEN gdp END) AS gdp_2020,\n      SUM(CASE WHEN year = 2015 THEN gdp END) AS gdp_2015\n    FROM \n      gdp_data\n    WHERE \n      year BETWEEN 2015 AND 2020\n    GROUP BY \n      country\n  ) subquery\nGROUP BY \n  country\nORDER BY \n  average_gdp_growth DESC\nLIMIT 15;\n```\nNote that this query assumes a simple calculation for average GDP growth, and you may need to adjust it depending on the specifics of your data. Additionally, the `ROW_NUMBER()` or `RANK()` functions may be more suitable for ranking the countries, depending on the desired output.",
    "augmentation_type": "cot",
    "original_question": "Rank countries by their average GDP growth from 2015 to 2020, showing only the top 15"
  },
  {
    "id": 61,
    "question": "Find the top 5 countries by combined GFS and GEM data availability (total observations)",
    "ground_truth_sql": "WITH combined AS (\n    SELECT country_id, 'GFS' AS source FROM gfs_observations\n    UNION ALL\n    SELECT country_id, 'GEM' AS source FROM gem_observations\n)\nSELECT c.country_name, \n       SUM(CASE WHEN source = 'GFS' THEN 1 ELSE 0 END) AS gfs_obs,\n       SUM(CASE WHEN source = 'GEM' THEN 1 ELSE 0 END) AS gem_obs,\n       COUNT(*) AS total_obs\nFROM combined\nJOIN countries c ON combined.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY total_obs DESC\nLIMIT 5",
    "difficulty": "hard",
    "category": "union_aggregation",
    "reasoning": "**Step 1: Identify the data needed and tables/columns to use**\n\n* We need data on GFS (Global Fire Emissions Database) and GEM (Global Emissions Model) observations.\n* The relevant tables likely contain information on observations, countries, and the specific data sources (GFS and GEM).\n* Let's assume we have three tables:\n\t+ `observations`: stores individual observations with columns for `id`, `country_id`, `gfs_observations`, and `gem_observations`.\n\t+ `countries`: stores information on countries with columns for `id` and `name`.\n\t+ `data_sources`: stores information on the data sources (GFS and GEM) with columns for `id`, `name`, and `source_type` (GFS or GEM).\n\n**Step 2: Determine the conditions and filters to apply**\n\n* We want to combine the GFS and GEM data availability (total observations).\n* Filter the data to only include countries with both GFS and GEM observations.\n* Assume that observations with `gfs_observations` > 0 and `gem_observations` > 0 are considered available.\n\n**Step 3: Define the aggregation and calculation needed**\n\n* We want to calculate the total number of available observations for each country.\n* This can be achieved by summing the `gfs_observations` and `gem_observations` columns for each country.\n\n**Step 4: Construct the SQL query**\n\n* Use a JOIN to combine the `observations` table with the `countries` table and the `data_sources` table.\n* Apply the conditions and filters to only include countries with both GFS and GEM observations.\n* Use an aggregation function (e.g., SUM) to calculate the total number of available observations for each country.\n* Finally, use the `ORDER BY` clause to sort the results by the total number of available observations in descending order and limit the output to the top 5 countries.\n\nHere is the SQL query:\n```sql\nSELECT c.name, \n       SUM(o.gfs_observations + o.gem_observations) AS total_available_observations\nFROM observations o\nJOIN countries c ON o.country_id = c.id\nJOIN data_sources ds1 ON o.id = ds1.observation_id AND ds1.source_type = 'GFS'\nJOIN data_sources ds2 ON o.id = ds2.observation_id AND ds2.source_type = 'GEM'\nWHERE o.gfs_observations > 0 AND o.gem_observations > 0\nGROUP BY c.name\nORDER BY total_available_observations DESC\nLIMIT 5;\n```\nNote: The exact table and column names may vary depending on the specific database schema.",
    "augmentation_type": "cot",
    "original_question": "Find the top 5 countries by combined GFS and GEM data availability (total observations)"
  },
  {
    "id": 62,
    "question": "Identify the year with the largest GDP drop for each major economy (US, China, Japan, Germany, UK) between 2008 and 2022",
    "ground_truth_sql": "WITH gdp_changes AS (\n    SELECT c.country_name, g.year, g.value AS gdp,\n           g.value - LAG(g.value) OVER (PARTITION BY c.country_name ORDER BY g.year) AS gdp_change\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ('United States', 'China', 'Japan', 'Germany', 'United Kingdom')\n    AND i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2008 AND 2022\n),\nranked AS (\n    SELECT country_name, year, gdp_change,\n           ROW_NUMBER() OVER (PARTITION BY country_name ORDER BY gdp_change ASC) AS rn\n    FROM gdp_changes\n    WHERE gdp_change IS NOT NULL\n)\nSELECT country_name, year AS worst_year, gdp_change AS gdp_drop\nFROM ranked\nWHERE rn = 1\nORDER BY gdp_drop ASC",
    "difficulty": "hard",
    "category": "window_function",
    "reasoning": "To answer the question, follow these steps:\n\n1. **Identify required data**:\n   - We need data on GDP for each major economy (US, China, Japan, Germany, UK) between 2008 and 2022.\n   - We also need the year as a separate column to perform aggregations.\n\n2. **Determine required tables and columns**:\n   - We assume a fact table named `gdp_data` with the following columns:\n     - `country`: The country name (e.g., US, China, etc.)\n     - `year`: The year of the GDP data (e.g., 2008, 2009, etc.)\n     - `gdp`: The GDP value for the given year and country\n   - We also assume a dimension table named `countries` with the following columns:\n     - `id`: A unique identifier for each country\n     - `name`: The country name (e.g., US, China, etc.)\n\n3. **Apply filters and conditions**:\n   - Filter the data to include only the specified countries (US, China, Japan, Germany, UK)\n   - Filter the data to include only the years between 2008 and 2022\n\n4. **Perform aggregations and calculations**:\n   - Perform a ranking operation to identify the year with the largest GDP drop for each country\n   - Calculate the GDP drop as the difference between the current year's GDP and the previous year's GDP\n\n5. **Write the SQL query**:\n\n```sql\nWITH \n-- Calculate GDP drop for each year and country\ngdp_drops AS (\n  SELECT \n    c.name AS country,\n    year,\n    gdp - LAG(gdp) OVER (PARTITION BY c.name ORDER BY year) AS gdp_drop\n  FROM \n    gdp_data\n  CROSS JOIN \n    countries c\n  WHERE \n    c.name IN ('US', 'China', 'Japan', 'Germany', 'UK')\n    AND year BETWEEN 2008 AND 2022\n)\n-- Rank years by GDP drop for each country\nSELECT \n  country,\n  year,\n  gdp_drop\nFROM \n  (\n    SELECT \n      country,\n      year,\n      gdp_drop,\n      ROW_NUMBER() OVER (PARTITION BY country ORDER BY gdp_drop DESC) AS rank\n    FROM \n      gdp_drops\n  ) AS subquery\nWHERE \n  rank = 1\nORDER BY \n  country, year;\n```\n\nThis query first calculates the GDP drop for each year and country using a Common Table Expression (CTE). Then, it uses another CTE to rank the years by GDP drop for each country. Finally, it selects the years with the largest GDP drop for each country.",
    "augmentation_type": "cot",
    "original_question": "Identify the year with the largest GDP drop for each major economy (US, China, Japan, Germany, UK) between 2008 and 2022"
  },
  {
    "id": 63,
    "question": "Compare tax revenues as a percentage of GDP across countries with good data coverage (Singapore, Australia, Israel, South Africa, Chile) for 2020, ranking them from highest to lowest",
    "ground_truth_sql": "WITH Tax_Revenue AS (\n    SELECT \n        c.country_name,\n        g.value AS tax_revenue_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ('Singapore', 'Australia', 'Israel', 'South Africa', 'Chile')\n        AND g.year = 2020\n        AND s.sector_name = 'General government'\n        AND i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n),\nAvg_Tax AS (\n    SELECT AVG(tax_revenue_pct_gdp) AS avg_tax_revenue\n    FROM Tax_Revenue\n)\nSELECT \n    t.country_name,\n    t.tax_revenue_pct_gdp,\n    a.avg_tax_revenue AS group_average,\n    (t.tax_revenue_pct_gdp - a.avg_tax_revenue) AS difference_from_avg\nFROM Tax_Revenue t\nCROSS JOIN Avg_Tax a\nORDER BY t.tax_revenue_pct_gdp DESC",
    "difficulty": "hard",
    "category": "cross_country_comparison",
    "reasoning": "Here's a step-by-step breakdown to construct the SQL query:\n\n**Step 1: Identify the necessary data and tables**\n\n* We need data on tax revenues and GDP for specific countries.\n* We assume we have the following tables:\n  - **tax_revenue**: contains tax revenue data for various countries and years.\n  - **gdp**: contains GDP data for various countries and years.\n  - **country_info**: contains information about countries, including their names and codes.\n\n**Step 2: Determine the necessary columns**\n\nNeed to use the following columns:\n\n  - **tax_revenue**: tax revenue amount\n  - **gdp**: GDP amount\n  - **country_name**: country name\n  - **year**: year of data\n\n**Step 3: Apply filters and conditions**\n\n* Filter the data to include only the countries with good data coverage (Singapore, Australia, Israel, South Africa, Chile).\n* Filter the data to include only the year 2020.\n* Consider adding a filter to exclude countries with missing data.\n\n**Step 4: Calculate the tax revenues as a percentage of GDP**\n\n* We need to calculate the tax revenue as a percentage of GDP for each country in 2020.\n* This involves dividing the tax revenue by the GDP and multiplying by 100 to get the percentage.\n\n**Step 5: Rank the countries by tax revenue as a percentage of GDP**\n\n* We need to rank the countries by the calculated percentage in descending order (highest to lowest).\n\n**Step 6: Write the SQL query**\n\nHere's the SQL query that puts all the steps together:\n```sql\nSELECT \n  ci.country_name,\n  (tr.tax_revenue / g.gdp) * 100 AS tax_revenue_percentage\nFROM \n  tax_revenue tr\n  INNER JOIN gdp g ON tr.country_code = g.country_code\n  INNER JOIN country_info ci ON g.country_code = ci.country_code\nWHERE \n  ci.country_name IN ('Singapore', 'Australia', 'Israel', 'South Africa', 'Chile')\n  AND g.year = 2020\n  AND g.gdp IS NOT NULL\n  AND tr.tax_revenue IS NOT NULL;\nORDER BY \n  tax_revenue_percentage DESC;\n```\nThis query joins the three tables based on common columns, filters the data to include only the specified countries and year, calculates the tax revenue as a percentage of GDP, and ranks the countries by this percentage in descending order.",
    "augmentation_type": "cot",
    "original_question": "Compare tax revenues as a percentage of GDP across countries with good data coverage (Singapore, Australia, Israel, South Africa, Chile) for 2020, ranking them from highest to lowest"
  },
  {
    "id": 64,
    "question": "Show the year-over-year change in net lending/borrowing for Singapore's general government from 2015 to 2022, identifying years with deficits (negative values)",
    "ground_truth_sql": "WITH Yearly_Values AS (\n    SELECT \n        g.year,\n        g.value AS current_value,\n        LAG(g.value) OVER (ORDER BY g.year) AS previous_value\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'Singapore'\n        AND s.sector_name = 'General government'\n        AND i.indicator_name = 'Net lending (+) / net borrowing (-), Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year BETWEEN 2015 AND 2022\n)\nSELECT \n    year,\n    current_value,\n    previous_value,\n    (current_value - previous_value) AS yoy_change,\n    CASE \n        WHEN current_value < 0 THEN 'Deficit'\n        ELSE 'Surplus'\n    END AS fiscal_status\nFROM Yearly_Values\nWHERE previous_value IS NOT NULL\nORDER BY year",
    "difficulty": "hard",
    "category": "temporal_analysis",
    "reasoning": "Here's a step-by-step breakdown of the SQL query to answer the question:\n\n**1. What data is needed:**\nTo answer this question, we need data on net lending/borrowing for Singapore's general government for the years 2015 to 2022. This data is typically found in a dataset related to government finance statistics.\n\n**2. Which tables/columns to use:**\nAssuming we have a dataset with the following structure:\n\n- `government_finances` table with columns:\n  - `year`: The year of the data (integer)\n  - `country`: The country name (string)\n  - `net_lending`: The net lending/borrowing amount (numeric)\n\nWe will use the `government_finances` table and its `year`, `country`, and `net_lending` columns.\n\n**3. What filters or conditions to apply:**\nWe need to filter the data for Singapore and the years 2015 to 2022. We also want to identify years with deficits (negative values).\n\n- Filter for Singapore: `country = 'Singapore'`\n- Filter for years 2015 to 2022: `year BETWEEN 2015 AND 2022`\n- Filter for deficits: `net_lending < 0`\n\n**4. What aggregations or calculations are needed:**\nWe want to calculate the year-over-year change in net lending/borrowing. We can use a self-join or a window function to calculate this change.\n\n- To calculate the year-over-year change, we can use a self-join or a window function with a lag or lead operation.\n\n**SQL Query:**\n\n```sql\nWITH year_change AS (\n  SELECT year, net_lending,\n    LAG(net_lending) OVER (ORDER BY year) AS prev_year_net_lending\n  FROM government_finances\n  WHERE country = 'Singapore' AND year BETWEEN 2015 AND 2022\n)\nSELECT year, net_lending,\n  (net_lending - prev_year_net_lending) AS year_over_year_change,\n  CASE WHEN (net_lending - prev_year_net_lending) < 0 THEN 'Deficit' ELSE 'Surplus' END AS year_over_year_status\nFROM year_change;\n```\n\nThis query uses a common table expression (CTE) to calculate the year-over-year change in net lending/borrowing. The `LAG` function is used to get the previous year's net lending amount. The query then selects the year, net lending amount, year-over-year change, and year-over-year status (deficit or surplus).",
    "augmentation_type": "cot",
    "original_question": "Show the year-over-year change in net lending/borrowing for Singapore's general government from 2015 to 2022, identifying years with deficits (negative values)"
  },
  {
    "id": 65,
    "question": "Calculate the correlation between government revenue and expenditure across all countries for 2019",
    "ground_truth_sql": "WITH paired_data AS (\n    SELECT c.country_name,\n           SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN g.value ELSE 0 END) AS revenue,\n           SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN g.value ELSE 0 END) AS expenditure\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND g.year = 2019\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN 1 ELSE 0 END) > 0\n),\nstats AS (\n    SELECT \n        COUNT(*) AS n,\n        SUM(revenue) AS sum_x,\n        SUM(expenditure) AS sum_y,\n        SUM(revenue * expenditure) AS sum_xy,\n        SUM(revenue * revenue) AS sum_xx,\n        SUM(expenditure * expenditure) AS sum_yy\n    FROM paired_data\n)\nSELECT \n    n AS sample_size,\n    (n * sum_xy - sum_x * sum_y) / \n    SQRT((n * sum_xx - sum_x * sum_x) * (n * sum_yy - sum_y * sum_y)) AS correlation\nFROM stats",
    "difficulty": "hard",
    "category": "statistical",
    "reasoning": "Here are the steps to construct the SQL query:\n\n**Step 1: Identify the necessary data and tables**\n\n* The question requires data on government revenue and expenditure across all countries for 2019.\n* We need to identify the relevant tables and columns that contain this data.\n* Let's assume we have the following tables:\n\t+ `country_data`: contains country-level data, including government revenue and expenditure.\n\t+ `country`: contains country information, including codes and names.\n\t+ `year`: contains year information, including start and end dates.\n\n**Step 2: Determine the necessary columns and filters**\n\n* We need to use the following columns:\n\t+ `revenue`: government revenue\n\t+ `expenditure`: government expenditure\n\t+ `country_code`: country code\n\t+ `year`: year\n* We need to apply the following filters:\n\t+ `year` = 2019\n\t+ `revenue` and `expenditure` are numeric values\n\n**Step 3: Determine the necessary aggregations or calculations**\n\n* We need to calculate the correlation between `revenue` and `expenditure` across all countries for 2019.\n* To do this, we need to calculate the mean and standard deviation of `revenue` and `expenditure` for each country, and then use these values to calculate the correlation coefficient.\n\n**Step 4: Write the SQL query**\n\nHere is the SQL query:\n```sql\nSELECT \n  CORR(revenue, expenditure) AS correlation\nFROM \n  country_data\nWHERE \n  year = 2019\n```\nThis query uses the `CORR` function to calculate the correlation between `revenue` and `expenditure` across all countries for 2019.\n\nNote: The `CORR` function is available in some databases, such as PostgreSQL and MySQL 8.0. If it's not available, you can use a custom implementation or a library function to calculate the correlation coefficient.\n\n**Step 5: Optional: Group by country or region**\n\nIf you want to calculate the correlation between `revenue` and `expenditure` for each country or region, you can add a `GROUP BY` clause:\n```sql\nSELECT \n  country_code,\n  CORR(revenue, expenditure) AS correlation\nFROM \n  country_data\nWHERE \n  year = 2019\nGROUP BY \n  country_code\nORDER BY \n  correlation DESC\n```\nThis query groups the results by country code and calculates the correlation coefficient for each group. The results are ordered by the correlation coefficient in descending order.",
    "augmentation_type": "cot",
    "original_question": "Calculate the correlation between government revenue and expenditure across all countries for 2019"
  },
  {
    "id": 66,
    "question": "Identify countries where total expenditure as percent of GDP for general government increased by more than 5 percentage points between 2019 and 2021",
    "ground_truth_sql": "WITH Expenditure_By_Year AS (\n    SELECT \n        c.country_name,\n        SUM(CASE WHEN g.year = 2019 THEN g.value ELSE 0 END) AS exp_2019,\n        SUM(CASE WHEN g.year = 2021 THEN g.value ELSE 0 END) AS exp_2021\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n        AND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year IN (2019, 2021)\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN g.year = 2019 THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN g.year = 2021 THEN 1 ELSE 0 END) > 0\n)\nSELECT \n    country_name,\n    exp_2019,\n    exp_2021,\n    (exp_2021 - exp_2019) AS change_pct_points\nFROM Expenditure_By_Year\nWHERE (exp_2021 - exp_2019) > 5\nORDER BY (exp_2021 - exp_2019) DESC",
    "difficulty": "hard",
    "category": "change_detection",
    "reasoning": "**Step 1: Identify Required Data and Tables**\n\nTo answer the question, we need to access the following tables and data:\n\n* A table with country-level data on total expenditure as percent of GDP for general government, including years 2019 and 2021.\n* A table with country-level data if needed to get the country names or country codes.\n\n**Step 2: Specify the Tables and Columns to Use**\n\nAssuming we have a table named `government_expenditure` with the following columns:\n\n* `country_code` (string): country code\n* `country_name` (string): country name\n* `year` (integer): year\n* `total_expenditure_percent_GDP` (float): total expenditure as percent of GDP for general government\n\n**Step 3: Define the Filters and Conditions**\n\nTo answer the question, we need to apply the following filters and conditions:\n\n* `year` = 2019 (for the base year)\n* `year` = 2021 (for the target year)\n* `total_expenditure_percent_GDP_2019` - `total_expenditure_percent_GDP_2021` > 5 (to identify countries where the percentage increased by more than 5 points)\n\n**Step 4: Calculate the Required Measures**\n\nTo answer the question, we need to calculate the following measures:\n\n* `total_expenditure_percent_GDP_2019`: total expenditure as percent of GDP for general government in 2019\n* `total_expenditure_percent_GDP_2021`: total expenditure as percent of GDP for general government in 2021\n* `change_in_percentage_points`: `total_expenditure_percent_GDP_2021` - `total_expenditure_percent_GDP_2019`\n\n**Step 5: Write the SQL Query**\n\nHere is the SQL query to answer the question:\n```sql\nWITH \n  -- Calculate total expenditure as percent of GDP for general government in 2019 and 2021\n  expenditure_2019 AS (\n    SELECT country_code, year, total_expenditure_percent_GDP AS total_expenditure_percent_GDP_2019\n    FROM government_expenditure\n    WHERE year = 2019\n  ),\n  -- Calculate total expenditure as percent of GDP for general government in 2021\n  expenditure_2021 AS (\n    SELECT country_code, year, total_expenditure_percent_GDP AS total_expenditure_percent_GDP_2021\n    FROM government_expenditure\n    WHERE year = 2021\n  )\n-- Identify countries where total expenditure as percent of GDP for general government increased by more than 5 percentage points between 2019 and 2021\nSELECT \n  e1.country_code, \n  e1.country_name, \n  e1.total_expenditure_percent_GDP_2019, \n  e2.total_expenditure_percent_GDP_2021, \n  e2.total_expenditure_percent_GDP_2021 - e1.total_expenditure_percent_GDP_2019 AS change_in_percentage_points\nFROM expenditure_2019 e1\nJOIN expenditure_2021 e2 ON e1.country_code = e2.country_code\nWHERE e2.total_expenditure_percent_GDP_2021 - e1.total_expenditure_percent_GDP_2019 > 5\n```\nNote: This query assumes that the `country_name` column is available in the `government_expenditure` table. If not, you may need to join the `country_code` column with another table to get the country names.",
    "augmentation_type": "cot",
    "original_question": "Identify countries where total expenditure as percent of GDP for general government increased by more than 5 percentage points between 2019 and 2021"
  },
  {
    "id": 67,
    "question": "Calculate the compound annual growth rate (CAGR) of GDP for India from 2010 to 2020",
    "ground_truth_sql": "WITH gdp_endpoints AS (\n    SELECT \n        MAX(CASE WHEN year = 2010 THEN value END) AS gdp_2010,\n        MAX(CASE WHEN year = 2020 THEN value END) AS gdp_2020\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'India'\n    AND i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year IN (2010, 2020)\n)\nSELECT gdp_2010, gdp_2020,\n       (POWER(gdp_2020 / gdp_2010, 1.0/10) - 1) * 100 AS cagr_percent\nFROM gdp_endpoints\nWHERE gdp_2010 > 0 AND gdp_2020 > 0",
    "difficulty": "hard",
    "category": "financial_calculation",
    "reasoning": "To calculate the compound annual growth rate (CAGR) of GDP for India from 2010 to 2020 using SQL, follow these steps:\n\n1. **Determine the required data**:\nThe data needed includes the GDP values for India for each year from 2010 to 2020.\n\n2. **Identify the relevant tables/columns**:\nAssuming the database contains a table named \"gdp_data\" with columns for country, year, and GDP value. If not, you might need to create a temporary table or use a pivot table to rearrange the data.\n\n   - Table: `gdp_data`\n   - Columns: `country`, `year`, `gdp`\n\n3. **Apply filters or conditions**:\nTo focus on India's GDP, filter the data by country and year range.\n\n   - Filter conditions: `country = 'India' AND year BETWEEN 2010 AND 2020`\n\n4. **Perform aggregations or calculations**:\nTo calculate the CAGR, first, calculate the logarithmic growth rate using the formula:\n\n   - `growth_rate = (log(gdp_next_year) - log(gdp_current_year)) / (year_next - year_current)`\n\nThen, to get the CAGR, use the formula:\n\n   - `cagr = (growth_rate + 1) ^ (1 / (year_next - year_current)) - 1`\n\nTo calculate the CAGR for each year, use a self-join or a subquery with a window function.\n\nHere's a sample SQL query to achieve this:\n\n```sql\nWITH gdp_growth AS (\n  SELECT country, year, gdp,\n         LAG(gdp, 1) OVER (PARTITION BY country ORDER BY year) AS prev_gdp\n  FROM gdp_data\n  WHERE country = 'India' AND year BETWEEN 2010 AND 2020\n)\nSELECT country, year, gdp,\n       (POWER(EXP(LOG(gdp) - LOG(prev_gdp)), (1.0 / (year - LAG(prev_gdp, 1) OVER (PARTITION BY country ORDER BY year)))) - 1) * 100 AS cagr\nFROM gdp_growth\nORDER BY country, year;\n```\n\nNote: This query assumes a PostgreSQL database. The syntax may vary depending on the database management system.",
    "augmentation_type": "cot",
    "original_question": "Calculate the compound annual growth rate (CAGR) of GDP for India from 2010 to 2020"
  },
  {
    "id": 68,
    "question": "Find countries where government revenue consistently exceeded expenditure (surplus) every year from 2015 to 2020",
    "ground_truth_sql": "WITH fiscal_balance AS (\n    SELECT c.country_name, g.year,\n           SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN g.value ELSE 0 END) AS revenue,\n           SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN g.value ELSE 0 END) AS expenditure\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND g.year BETWEEN 2015 AND 2020\n    GROUP BY c.country_name, g.year\n    HAVING SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN 1 ELSE 0 END) > 0\n)\nSELECT country_name, COUNT(*) AS years_with_data,\n       SUM(CASE WHEN revenue > expenditure THEN 1 ELSE 0 END) AS surplus_years\nFROM fiscal_balance\nGROUP BY country_name\nHAVING COUNT(*) >= 5 AND SUM(CASE WHEN revenue > expenditure THEN 1 ELSE 0 END) = COUNT(*)\nORDER BY country_name",
    "difficulty": "hard",
    "category": "complex_aggregation",
    "reasoning": "To answer the question, we need to follow these steps:\n\n1. **Identify the necessary data**:\n   - We need to access a database containing financial data for countries.\n   - The database should have tables with information about government revenue and expenditure for each country over the years.\n\n2. **Determine the specific tables and columns to use**:\n   - **Country Table**: This table stores basic information about each country, including the name and ID.\n   - **Financial Data Table**: This table contains financial data for each country, including government revenue and expenditure, and the year.\n   - **Columns**:\n     - `country_id` or `country_name` to relate financial data to the corresponding country.\n     - `revenue` or `income` for government revenue.\n     - `expenditure` for government expenditure.\n     - `year` to filter data by year.\n\n3. **Apply filters and conditions**:\n   - **Year Filter**: Filter the data to include only years from 2015 to 2020.\n   - **Filter for Surplus**: Select countries where the government revenue exceeded expenditure (`revenue > expenditure`) for each year.\n\n4. **Perform aggregations or calculations**:\n   - **Group by Country**: Group the data by country to identify which countries consistently had a surplus.\n   - **Aggregate Function**: Use an aggregate function, such as `COUNT` or `SUM`, to count the number of years where the surplus condition was met.\n   - **HAVING Clause**: Apply a filter to only include countries where the aggregated count of surplus years meets a certain condition (e.g., all years from 2015 to 2020).\n\n5. **Construct the SQL Query**:\n   - Use a subquery or a common table expression (CTE) to first identify the countries with a surplus condition for each year.\n   - Then, use the `GROUP BY` clause to count the number of surplus years for each country.\n   - Apply the `HAVING` clause to filter the results to only include countries with a surplus in all years from 2015 to 2020.\n\nExample SQL Query:\n```sql\nWITH Surplus_Countries AS (\n  SELECT country_id, year\n  FROM Financial_Data\n  WHERE year BETWEEN 2015 AND 2020\n  AND revenue > expenditure\n)\nSELECT country_id\nFROM (\n  SELECT country_id, COUNT(year) as surplus_count\n  FROM Surplus_Countries\n  GROUP BY country_id\n) AS Grouped_Surplus\nHAVING surplus_count = 6;  -- all years from 2015 to 2020\n```\nThis SQL query first identifies the countries with a surplus condition for each year in the `Surplus_Countries` CTE. Then, it counts the number of surplus years for each country and filters the results to only include countries with a surplus in all years from 2015 to 2020.",
    "augmentation_type": "cot",
    "original_question": "Find countries where government revenue consistently exceeded expenditure (surplus) every year from 2015 to 2020"
  },
  {
    "id": 69,
    "question": "Find the country with the largest deterioration in net lending/borrowing (as percent of GDP) during 2019-2020",
    "ground_truth_sql": "WITH balance AS (\n    SELECT\n        c.country_name,\n        g.year,\n        g.value AS net_lending_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n        AND i.indicator_name = 'Net lending (+) / net borrowing (-), Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year IN (2019, 2020)\n),\npaired AS (\n    SELECT\n        b2019.country_name,\n        b2019.net_lending_pct_gdp AS value_2019,\n        b2020.net_lending_pct_gdp AS value_2020,\n        (b2020.net_lending_pct_gdp - b2019.net_lending_pct_gdp) AS change_2020_minus_2019\n    FROM balance b2019\n    JOIN balance b2020\n      ON b2019.country_name = b2020.country_name\n     AND b2019.year = 2019\n     AND b2020.year = 2020\n)\nSELECT\n    country_name,\n    value_2019,\n    value_2020,\n    change_2020_minus_2019\nFROM paired\nORDER BY change_2020_minus_2019 ASC\nLIMIT 1",
    "difficulty": "hard",
    "category": "temporal_analysis",
    "reasoning": "**Step-by-Step Guide to Constructing the SQL Query**\n\n**1. Identify the Data Needed**\n\nTo answer the question, we need data on net lending/borrowing as a percentage of GDP for each country in 2019 and 2020. The relevant data columns are:\n\n- `country_name` (or a unique identifier for the country)\n- `net_lending_borrowing` (or a similar column representing the net lending/borrowing amount)\n- `gdp` (or a similar column representing the GDP)\n- `year` (or a similar column representing the year)\n\n**2. Choose the Tables and Columns to Use**\n\nThe required tables are likely to be a dataset containing economic indicators, which can be named `economic_indicators` or `econ_data`. Assuming the columns are named as mentioned earlier, the query can use the following columns:\n\n- `country_name`\n- `net_lending_borrowing`\n- `gdp`\n- `year`\n\n**3. Apply Filters and Conditions**\n\nTo answer the question, we need to filter the data for the years 2019 and 2020. We can use a `WHERE` clause to apply this filter.\n\nAdditionally, we need to calculate the percentage change in net lending/borrowing for each country between 2019 and 2020. To do this, we can use a subquery or a Common Table Expression (CTE) to first calculate the percentage change.\n\n**4. Calculate the Aggregations and Percentages**\n\nTo find the country with the largest deterioration, we need to calculate the percentage change in net lending/borrowing for each country. This can be done using the following formula:\n\n((`net_lending_borrowing_2020` - `net_lending_borrowing_2019`) / `net_lending_borrowing_2019`) * 100\n\nWe can then sort the results by this percentage change in descending order to find the country with the largest deterioration.\n\n**5. Construct the SQL Query**\n\nHere's the complete SQL query:\n```sql\nWITH \n  percent_change AS (\n    SELECT \n      country_name,\n      (net_lending_borrowing_2020 - net_lending_borrowing_2019) / net_lending_borrowing_2019 * 100 AS percentage_change\n    FROM \n      economic_indicators\n    WHERE \n      year = 2020\n  )\nSELECT \n  country_name,\n  percentage_change\nFROM \n  percent_change\nWHERE \n  percentage_change IS NOT NULL\nORDER BY \n  percentage_change DESC\nLIMIT 1;\n```\nThis query first calculates the percentage change in net lending/borrowing for each country in 2020 compared to 2019. It then selects the country with the largest deterioration (i.e., the highest negative percentage change) from the results.",
    "augmentation_type": "cot",
    "original_question": "Find the country with the largest deterioration in net lending/borrowing (as percent of GDP) during 2019-2020"
  },
  {
    "id": 70,
    "question": "Compare government revenue and expenditure as percent of GDP for Australia across all available years, showing the fiscal balance (revenue minus expenditure)",
    "ground_truth_sql": "SELECT\n    g.year,\n    SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS revenue_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS expenditure_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) -\n    SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS fiscal_balance\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\n    AND s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND i.indicator_name IN ('Revenue, Transactions (cash basis of recording), Cash basis', \n                             'Expenditure, Transactions (cash basis of recording), Cash basis')\nGROUP BY g.year\nHAVING SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN 1 ELSE 0 END) > 0\n   AND SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN 1 ELSE 0 END) > 0\nORDER BY g.year",
    "difficulty": "hard",
    "category": "cross_indicator_comparison",
    "reasoning": "To answer the question, follow these steps:\n\n1. **Data Needed:**\n   - Government revenue data\n   - Government expenditure data\n   - GDP data for each year\n   - Possibly additional data for fiscal year boundaries (start and end dates)\n\n2. **Tables/Columns to Use:**\n   - `revenue` table with columns: `year`, `country`, `revenue`\n   - `expenditure` table with columns: `year`, `country`, `expenditure`\n   - `gdp` table with columns: `year`, `country`, `gdp`\n   - `fiscal_year_boundaries` table with columns: `start_date`, `end_date`, `fiscal_year`\n\n3. **Filters or Conditions to Apply:**\n   - Filter data to only include Australia (`country = 'Australia'`)\n   - Filter data to include all available years\n\n4. **Calculations Needed:**\n   - Calculate revenue as a percentage of GDP (`revenue / gdp * 100`)\n   - Calculate expenditure as a percentage of GDP (`expenditure / gdp * 100`)\n   - Calculate the fiscal balance (`revenue - expenditure`)\n   - Calculate the fiscal balance as a percentage of GDP (`(revenue - expenditure) / gdp * 100`)\n\n5. **SQL Query:**\n   ```sql\nWITH \n  revenue_percent_of_gdp AS (\n    SELECT \n      year, \n      country, \n      revenue, \n      (revenue / gdp) * 100 AS revenue_percent\n    FROM \n      revenue\n    JOIN \n      gdp ON revenue.year = gdp.year AND revenue.country = gdp.country\n  ),\n  expenditure_percent_of_gdp AS (\n    SELECT \n      year, \n      country, \n      expenditure, \n      (expenditure / gdp) * 100 AS expenditure_percent\n    FROM \n      expenditure\n    JOIN \n      gdp ON expenditure.year = gdp.year AND expenditure.country = gdp.country\n  )\nSELECT \n  r.year, \n  r.country, \n  r.revenue_percent, \n  e.expenditure_percent, \n  r.revenue_percent - e.expenditure_percent AS fiscal_balance_percent\nFROM \n  revenue_percent_of_gdp r\nJOIN \n  expenditure_percent_of_gdp e ON r.year = e.year AND r.country = e.country\nWHERE \n  r.country = 'Australia'\nORDER BY \n  r.year;\n```\nThis query uses Common Table Expressions (CTEs) to calculate the revenue and expenditure as a percentage of GDP, and then joins these two CTEs to calculate the fiscal balance. The final result is ordered by year.",
    "augmentation_type": "cot",
    "original_question": "Compare government revenue and expenditure as percent of GDP for Australia across all available years, showing the fiscal balance (revenue minus expenditure)"
  }
]