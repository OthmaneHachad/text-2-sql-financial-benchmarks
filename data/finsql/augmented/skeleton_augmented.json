[
  {
    "id": 1,
    "question": "\"Calculate the average or total of [metric] grouped by [dimension] in the [table]\"\n\nThis generic question describes the query type as calculating a metric, grouping it by a specific dimension, and utilizing a particular table.",
    "ground_truth_sql": "SELECT sector_id, sector_name FROM sectors ORDER BY sector_id",
    "difficulty": "simple",
    "category": "select_all",
    "original_question": "List all sector names and their IDs",
    "sql_skeleton": "SELECT sector_id, sector_name FROM sectors ORDER BY sector_id",
    "pattern_type": "sorted_retrieval",
    "augmentation_type": "skeleton"
  },
  {
    "id": 2,
    "question": "\"Retrieve specific attribute from a set of [table] records where the attribute contains [STRING]\"",
    "ground_truth_sql": "SELECT country_name FROM countries WHERE country_name LIKE '%United%'",
    "difficulty": "simple",
    "category": "pattern_match",
    "original_question": "Find all countries with 'United' in their name",
    "sql_skeleton": "SELECT country_name FROM countries WHERE country_name LIKE [STRING]",
    "pattern_type": "simple_select",
    "augmentation_type": "skeleton"
  },
  {
    "id": 3,
    "question": "\"Retrieve count of specific metric for [dimension] with specific characteristic\"\n\nThis generic question describes the query type without specific values, focusing on the structure and purpose of the query rather than the exact details. \n\nThe placeholders used are:\n\n- [dimension] for the table or category being queried (e.g., 'indicators', 'sectors')\n- [metric] for the specific value being counted or calculated (e.g., 'count', 'GDP')\n- [characteristic] for the specific attribute or condition being applied (e.g., 'source', 'sector')",
    "ground_truth_sql": "SELECT COUNT(*) AS gfs_indicator_count FROM indicators WHERE source = 'GFS'",
    "difficulty": "simple",
    "category": "count_filtered",
    "original_question": "How many GFS indicators are there?",
    "sql_skeleton": "SELECT COUNT(*) AS gfs_indicator_count FROM indicators WHERE source = [STRING]",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 4,
    "question": "\"Retrieve specific metric from [table] where [dimension] matches [string]\"",
    "ground_truth_sql": "SELECT DISTINCT indicator_name FROM indicators WHERE source = 'GFS' AND indicator_name LIKE '%Revenue%'",
    "difficulty": "simple",
    "category": "pattern_match",
    "original_question": "List all GFS indicator names that contain 'Revenue'",
    "sql_skeleton": "SELECT DISTINCT indicator_name FROM indicators WHERE source = [STRING] AND indicator_name LIKE [STRING]",
    "pattern_type": "simple_select",
    "augmentation_type": "skeleton"
  },
  {
    "id": 5,
    "question": "Retrieve specific attribute from a table where attribute matches a given condition.",
    "ground_truth_sql": "SELECT country_name FROM countries WHERE country_name LIKE 'A%' ORDER BY country_name",
    "difficulty": "simple",
    "category": "pattern_match",
    "original_question": "List countries whose names start with 'A'",
    "sql_skeleton": "SELECT country_name FROM countries WHERE country_name LIKE [STRING] ORDER BY country_name",
    "pattern_type": "sorted_retrieval",
    "augmentation_type": "skeleton"
  },
  {
    "id": 6,
    "question": "\"Calculate aggregate of [metric] across [dimension]\"\n\nThis generic question describes the query type without specific values, focusing on the core idea of the query: calculating an aggregate (in this case, a count) of a metric (observation_count) across a dimension (the table name, gem_observations).",
    "ground_truth_sql": "SELECT COUNT(*) AS observation_count FROM gem_observations",
    "difficulty": "simple",
    "category": "count",
    "original_question": "How many GEM observations are in the database?",
    "sql_skeleton": "SELECT COUNT(*) AS observation_count FROM gem_observations",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 7,
    "question": "\"Retrieve the total count of records in a specific [table]\"\n\nThis generic question describes the query type without using specific values, focusing on the action being performed (retrieving a count) and the key elements involved (a specific table).",
    "ground_truth_sql": "SELECT COUNT(*) AS observation_count FROM gfs_observations",
    "difficulty": "simple",
    "category": "count",
    "original_question": "How many GFS observations are in the database?",
    "sql_skeleton": "SELECT COUNT(*) AS observation_count FROM gfs_observations",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 8,
    "question": "\"Retrieve distinct values of [metric] from [table] where [filter] is true, ordered by [metric]\"\n\nThis generic question describes the SQL pattern without specific values, focusing on the essential elements of the query:\n\n- [metric]: The attribute being retrieved (in this case, indicator_name).\n- [table]: The table containing the data (indicators).\n- [filter]: The condition applied to the data (source = [STRING]).\n- ordered by [metric]: The attribute used for sorting the results.",
    "ground_truth_sql": "SELECT DISTINCT indicator_name FROM indicators WHERE source = 'GEM' ORDER BY indicator_name",
    "difficulty": "simple",
    "category": "distinct_filtered",
    "original_question": "List all distinct GEM indicator names",
    "sql_skeleton": "SELECT DISTINCT indicator_name FROM indicators WHERE source = [STRING] ORDER BY indicator_name",
    "pattern_type": "sorted_retrieval",
    "augmentation_type": "skeleton"
  },
  {
    "id": 9,
    "question": "\"Retrieve the total count of unique [metric] in the [table] that match a specific [dimension] or criterion.\"\n\nThis generic question describes the type of query that the provided SQL pattern represents, without specifying any particular values. The placeholders are designed to be general and applicable to various query scenarios.",
    "ground_truth_sql": "SELECT COUNT(*) AS gem_indicator_count FROM indicators WHERE source = 'GEM'",
    "difficulty": "simple",
    "category": "count_filtered",
    "original_question": "How many GEM indicators are there?",
    "sql_skeleton": "SELECT COUNT(*) AS gem_indicator_count FROM indicators WHERE source = [STRING]",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 10,
    "question": "\"Retrieve earliest [metric] for a given [table]\"\n\nThis generic question describes the query type, which is to retrieve the minimum or earliest value of a metric from a table. It does not specify the actual metric, table, or any other values, making it a generic pattern. \n\nThis pattern can be applied to various other queries, such as:\n\n- \"Retrieve latest [metric] for a given [table]\"\n- \"Calculate average of [metric] grouped by [dimension]\" \n- \"Compare [metric] between two [tables]\"",
    "ground_truth_sql": "SELECT MIN(year) AS earliest_year FROM gfs_observations",
    "difficulty": "simple",
    "category": "min",
    "original_question": "What is the earliest year in the GFS observations?",
    "sql_skeleton": "SELECT MIN([YEAR]) AS earliest_year FROM gfs_observations",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 11,
    "question": "\"Calculate total count of [metric] in [table]\"\n\nThis generic question describes the query type without specific values, using placeholders for the metric and table.",
    "ground_truth_sql": "SELECT COUNT(*) AS indicator_count FROM indicators",
    "difficulty": "simple",
    "category": "count",
    "original_question": "How many different indicators are there in total?",
    "sql_skeleton": "SELECT COUNT(*) AS indicator_count FROM indicators",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 12,
    "question": "\"Calculate the count of distinct [dimension] from [table].\"\n\nThis generic question describes the query type without specific values, using placeholders for the key components of the query.",
    "ground_truth_sql": "SELECT COUNT(DISTINCT country_id) AS country_count FROM gem_observations",
    "difficulty": "simple",
    "category": "count_distinct",
    "original_question": "How many distinct countries have GEM data?",
    "sql_skeleton": "SELECT COUNT(DISTINCT [ID]) AS country_count FROM gem_observations",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 13,
    "question": "\"Find the minimum value of a metric aggregated across all observations in a table\"\n\nThis generic question captures the essence of the original query, which is to find the minimum value of a specific metric ([METRIC]) in a table ([table]) while excluding null values.",
    "ground_truth_sql": "SELECT MIN(value) AS min_value FROM gem_observations WHERE value IS NOT NULL",
    "difficulty": "simple",
    "category": "min",
    "original_question": "Find the minimum value in GEM observations (excluding nulls)",
    "sql_skeleton": "SELECT MIN([METRIC]) AS min_value FROM gem_observations WHERE [METRIC] IS NOT NULL",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 14,
    "question": "\"Retrieve count of observations with specific transformation type\"\n\nThis generic question captures the essence of the original SQL query, focusing on the act of retrieving a count of observations based on a specific characteristic (in this case, the transformation type).",
    "ground_truth_sql": "SELECT COUNT(*) AS count FROM gfs_observations WHERE transformation = 'Percent of GDP'",
    "difficulty": "simple",
    "category": "count_filtered",
    "original_question": "How many observations have 'Percent of GDP' as the transformation?",
    "sql_skeleton": "SELECT COUNT(*) AS count FROM gfs_observations WHERE transformation = [STRING]",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 15,
    "question": "\"Retrieve the maximum value of [metric] from [table]\"\n\nThis generic question describes the query type, which is to retrieve the maximum value of a metric from a specific table, without specifying the particular metric, table, or values.",
    "ground_truth_sql": "SELECT MAX(year) AS latest_year FROM gem_observations",
    "difficulty": "simple",
    "category": "max",
    "original_question": "What is the latest year in the GEM observations?",
    "sql_skeleton": "SELECT MAX([YEAR]) AS latest_year FROM gem_observations",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 16,
    "question": "\"Retrieve distinct values of [metric] from [table] where [dimension] matches [value pattern] and [filter dimension] equals [string value]\"\n\nThis generic question captures the essence of the original query, replacing specific values with placeholders. \n\nAlternatively, you could phrase it as:\n\n\"Extract unique [metric] names from [table] where [dimension] contains [string pattern] and [filter dimension] is [string value]\".\n\nBoth versions describe the query type without referencing specific values, making it a generic question that can be applied to various SQL queries with similar patterns.",
    "ground_truth_sql": "SELECT DISTINCT indicator_name FROM indicators WHERE source = 'GFS' AND indicator_name LIKE '%Expense%'",
    "difficulty": "simple",
    "category": "pattern_match",
    "original_question": "List all GFS indicator names that contain 'Expense'",
    "sql_skeleton": "SELECT DISTINCT indicator_name FROM indicators WHERE source = [STRING] AND indicator_name LIKE [STRING]",
    "pattern_type": "simple_select",
    "augmentation_type": "skeleton"
  },
  {
    "id": 17,
    "question": "\"Calculate [metric] count for [dimension] in [table]\"",
    "ground_truth_sql": "SELECT COUNT(*) AS country_count FROM countries",
    "difficulty": "simple",
    "category": "count",
    "original_question": "How many countries are in the database?",
    "sql_skeleton": "SELECT COUNT(*) AS country_count FROM countries",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 18,
    "question": "\"Retrieve specific metric from a table\"\n\nThis generic question describes the query type without specifying any values, using placeholders that can be filled in to represent the actual query.",
    "ground_truth_sql": "SELECT country_id, country_name FROM countries WHERE country_name = 'Brazil'",
    "difficulty": "simple",
    "category": "lookup",
    "original_question": "Find the country ID for Brazil",
    "sql_skeleton": "SELECT [ID], country_name FROM countries WHERE country_name = [STRING]",
    "pattern_type": "simple_select",
    "augmentation_type": "skeleton"
  },
  {
    "id": 19,
    "question": "\"Retrieve count of metric from table for given year\"\n\nThis generic question describes the query type, using placeholders like [metric], [table], and [year], without specific values.",
    "ground_truth_sql": "SELECT COUNT(*) AS obs_count FROM gem_observations WHERE year = 2020",
    "difficulty": "simple",
    "category": "count_filtered",
    "original_question": "How many GEM observations are from the year 2020?",
    "sql_skeleton": "SELECT COUNT(*) AS obs_count FROM gem_observations WHERE [YEAR] = [NUMBER]",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 20,
    "question": "\"Retrieve distinct values of a dimension from a given table\"\n\nThis generic question describes the query type as a simple retrieval of unique values from a table, without specifying the actual metric, table, or dimension used in the original SQL pattern.",
    "ground_truth_sql": "SELECT sector_name FROM sectors ORDER BY sector_name",
    "difficulty": "simple",
    "category": "select_all",
    "original_question": "List all available sectors in the GFS data",
    "sql_skeleton": "SELECT sector_name FROM sectors ORDER BY sector_name",
    "pattern_type": "sorted_retrieval",
    "augmentation_type": "skeleton"
  },
  {
    "id": 21,
    "question": "\"Retrieve count of observations for a given year\"\n\nThis generic question describes the query type as a COUNT operation on a specific table (gfs_observations) filtered by a specific year, without referencing specific values.",
    "ground_truth_sql": "SELECT COUNT(*) AS obs_count FROM gfs_observations WHERE year = 2020",
    "difficulty": "simple",
    "category": "count_filtered",
    "original_question": "How many GFS observations are from the year 2020?",
    "sql_skeleton": "SELECT COUNT(*) AS obs_count FROM gfs_observations WHERE [YEAR] = [NUMBER]",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 22,
    "question": "\"Retrieve distinct countries where specific [metric] data is available for [year]\"\n\nThis generic question describes the type of query as retrieving distinct countries based on the availability of specific data for a given year.",
    "ground_truth_sql": "SELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE g.year = 2023\nORDER BY c.country_name",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "List countries with GFS data available for 2023",
    "sql_skeleton": "SELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nWHERE g.[YEAR] = [NUMBER]\nORDER BY c.country_name",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 23,
    "question": "\"Retrieve years where a specific country has data for a particular metric within a certain sector.\"\n\nThis generic question describes the query type without specific values, matching the SQL pattern:\n\nSELECT DISTINCT g.[YEAR]\nFROM [table] g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.[sector_id] = s.[sector_id]\nWHERE c.[country_name] = [STRING]\nAND s.[sector_name] = [STRING]\nORDER BY g.[YEAR]",
    "ground_truth_sql": "SELECT DISTINCT g.year\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE c.country_name = 'France'\nAND s.sector_name = 'General government'\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "List all years where France has general government GFS data",
    "sql_skeleton": "SELECT DISTINCT g.[YEAR]\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE c.country_name = [STRING]\nAND s.sector_name = [STRING]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 24,
    "question": "\"Retrieve specific metric for given country over a specified time period\"\n\nThis generic question captures the essence of the query, which involves retrieving a specific metric (e.g., expenditure as a percentage of GDP) for a given country (Brazil) over a specified time period (2015 to 2022).",
    "ground_truth_sql": "SELECT g.year, g.value AS expenditure_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2015 AND 2022\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show total government expenditure (percent of GDP) for Brazil from 2015 to 2022",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS expenditure_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND s.sector_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.transformation = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 25,
    "question": "\"Calculate the average of a specific metric across all countries, grouped by the sector dimension.\"\n\nThis generic question captures the essence of the SQL query without specifying any concrete values, focusing on the type of operation (average calculation) and the dimension of grouping (sector). It uses placeholders like \"[metric]\" and \"[dimension]\" to convey the idea of a generic query.",
    "ground_truth_sql": "SELECT AVG(g.value) AS avg_revenue_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = 'General government'\nAND i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year = 2020",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "What is the average revenue (percent of GDP) for general government in 2020 across all countries?",
    "sql_skeleton": "SELECT AVG(g.[METRIC]) AS avg_revenue_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.transformation = [STRING]\nAND g.[YEAR] = [NUMBER]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 26,
    "question": "\"Calculate the total count of [metric] per [dimension]\".\n\nThis generic question captures the essence of the SQL query, which is to count the occurrences of a particular [metric] grouped by a specific [dimension]. The placeholders [metric] and [dimension] can be replaced with actual values to create specific queries.",
    "ground_truth_sql": "SELECT i.indicator_name, i.unit, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nGROUP BY i.indicator_name, i.unit\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "What is the total count of observations per GEM indicator?",
    "sql_skeleton": "SELECT i.indicator_name, i.unit, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nGROUP BY i.indicator_name, i.unit\nORDER BY obs_count DESC",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 27,
    "question": "\"Retrieve total count of [metric] by [dimension]\"\n\nThis generic question describes the query type without specific values, indicating that it's a type of aggregation query (COUNT) that groups data by a specific dimension (scale) and retrieves the total count.",
    "ground_truth_sql": "SELECT scale, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY scale\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "aggregation",
    "original_question": "Count GFS observations by scale type",
    "sql_skeleton": "SELECT scale, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY scale\nORDER BY obs_count DESC",
    "pattern_type": "grouped_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 28,
    "question": "\"Count the number of unique [country] that have [metric] data available for each [year]\"\n\nThis generic question captures the essence of the original query, which is to count the number of countries with a specific metric (unemployment rate) for each year, without specifying the actual values.",
    "ground_truth_sql": "SELECT g.year, COUNT(DISTINCT g.country_id) AS country_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nGROUP BY g.year\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "Count how many countries have GEM unemployment data for each year",
    "sql_skeleton": "SELECT g.[YEAR], COUNT(DISTINCT g.[ID]) AS country_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\nGROUP BY g.[YEAR]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 29,
    "question": "Generic Question: \"Count the number of unique [country] in [table] for each [year]\"\n\nThis generic question captures the essence of the original query, focusing on the query type (counting unique countries) rather than the specific values (e.g., \"GEM data\" and specific years).",
    "ground_truth_sql": "SELECT year, COUNT(DISTINCT country_id) AS country_count\nFROM gem_observations\nGROUP BY year\nORDER BY year",
    "difficulty": "medium",
    "category": "aggregation",
    "original_question": "Count the number of countries with GEM data for each year",
    "sql_skeleton": "SELECT [YEAR], COUNT(DISTINCT [ID]) AS country_count\nFROM gem_observations\nGROUP BY [YEAR]\nORDER BY [YEAR]",
    "pattern_type": "grouped_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 30,
    "question": "\"Retrieve the top [number] countries with the highest [metric] in [year]\"\n\nThis generic question captures the essence of the original SQL query, which is to retrieve a specific number of countries with the highest value of a particular metric in a given year.",
    "ground_truth_sql": "SELECT c.country_name, g.value AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'GDP at market prices'\nAND i.unit = 'constant 2010 US$, millions'\nAND g.year = 2019\nORDER BY g.value DESC\nLIMIT 10",
    "difficulty": "medium",
    "category": "join_filter_limit",
    "original_question": "List the 10 countries with the highest GDP (constant 2010 US$) in 2019",
    "sql_skeleton": "SELECT c.country_name, g.[METRIC] AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\nAND i.unit = [STRING]\nAND g.[YEAR] = [NUMBER]\nORDER BY g.[METRIC] DESC\nLIMIT [NUMBER]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 31,
    "question": "\"Calculate the average value of a metric across a specific dimension grouped by a set of categories.\"\n\nThis generic question captures the essence of the SQL query pattern provided, without referencing specific tables, columns, or values.",
    "ground_truth_sql": "SELECT s.sector_name, AVG(g.value) AS avg_value\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE g.year = 2020\nGROUP BY s.sector_name\nORDER BY avg_value DESC",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "What is the average value by sector for GFS observations in 2020?",
    "sql_skeleton": "SELECT s.sector_name, AVG(g.[METRIC]) AS avg_value\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE g.[YEAR] = [NUMBER]\nGROUP BY s.sector_name\nORDER BY avg_value DESC",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 32,
    "question": "\"Retrieve aggregated metric for single country, grouped by [dimension], over a range of [year]\"\n\nThis generic question captures the essence of the original SQL query, replacing specific values with placeholders:\n\n- [metric] is replaced by \"aggregated metric\" since the query counts observations.\n- [country] is explicitly mentioned as a single country.\n- [dimension] is replaced by \"[year]\" since the query groups by year.\n- [year] is replaced by \"a range of [year]\" to indicate that the query considers multiple years.\n\nThis generic question can be applied to various SQL queries that follow a similar pattern, making it a useful template for understanding the type of query being executed.",
    "ground_truth_sql": "SELECT g.year, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE c.country_name = 'United States'\nGROUP BY g.year\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "Count the number of GFS observations per year for the United States",
    "sql_skeleton": "SELECT g.[YEAR], COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nWHERE c.country_name = [STRING]\nGROUP BY g.[YEAR]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 33,
    "question": "\"Retrieve a specific metric for a country over a range of years\"",
    "ground_truth_sql": "SELECT g.year, g.value AS terms_of_trade\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\nAND i.indicator_name = 'Terms of Trade'\nAND g.year BETWEEN 2010 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show terms of trade for Australia from 2010 to 2023",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS terms_of_trade\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 34,
    "question": "\"Retrieve historical data for a specific [metric] in [country] within a specified [year] range\"\n\nThis generic question captures the essence of the original query, which involves retrieving data for a particular metric (exchange rate) in a specific country (Mexico) over a certain time period (2015-2023). By using placeholders like [metric], [country], and [year], the question can be applied to various scenarios involving different metrics, countries, and time ranges.",
    "ground_truth_sql": "SELECT g.year, g.value AS exchange_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Mexico'\nAND i.indicator_name = 'Exchange rate'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show the exchange rate for Mexico from 2015 to 2023",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS exchange_rate\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 35,
    "question": "\"Retrieve and summarize [metric] by [dimension], grouped by [grouping_dimension], and ordered by the [order_by_metric] for [entity] in [table].\"",
    "ground_truth_sql": "SELECT c.country_name, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "List countries and the number of GFS observations for each",
    "sql_skeleton": "SELECT c.country_name, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nGROUP BY c.country_name\nORDER BY obs_count DESC",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 36,
    "question": "\"Retrieve the maximum value of a specific metric for a country across different years.\"\n\nThis generic question describes the query type without specific values, focusing on the core characteristics of the original SQL pattern.",
    "ground_truth_sql": "SELECT c.country_name, g.year, g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nORDER BY g.value DESC\nLIMIT 1",
    "difficulty": "medium",
    "category": "join_filter_limit",
    "original_question": "What is the maximum unemployment rate recorded in GEM data and which country-year?",
    "sql_skeleton": "SELECT c.country_name, g.[YEAR], g.[METRIC] AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\nORDER BY g.[METRIC] DESC\nLIMIT [NUMBER]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 37,
    "question": "\"Show metric for a specific country across all available years\"\n\nThis generic question describes the query type without specific values, using placeholders like [metric], [country], and [year].",
    "ground_truth_sql": "SELECT g.year, g.value AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'United States'\nAND i.indicator_name = 'GDP at market prices'\nAND i.unit = 'constant 2010 US$, millions'\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show GDP at market prices for the United States for all available years",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND i.unit = [STRING]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 38,
    "question": "\"Retrieve country-year pairs with high [metric] value (> [threshold]) from [table] data between [start_year] and [end_year]\"",
    "ground_truth_sql": "SELECT\n    c.country_name,\n    g.year,\n    g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\n    AND g.year BETWEEN 2010 AND 2020\n    AND g.value > 10\nORDER BY g.value DESC",
    "difficulty": "medium",
    "category": "filtering",
    "original_question": "Find country-years with high unemployment rate (>10%) from GEM data between 2010 and 2020",
    "sql_skeleton": "SELECT\n    c.country_name,\n    g.[YEAR],\n    g.[METRIC] AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\n    AND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\n    AND g.[METRIC] > [NUMBER]\nORDER BY g.[METRIC] DESC",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 39,
    "question": "\"Retrieve specific metric for a country over a range of years, filtered by sector and indicator type.\"\n\nThis generic question captures the essence of the original SQL query, abstracting away the specific details like the country, metric, and years, while still conveying the main intent of the query.",
    "ground_truth_sql": "SELECT g.year, g.value AS social_benefits_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Germany'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Social benefits, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2000 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show government social benefits (percent of GDP) for Germany from 2000 to 2020",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS social_benefits_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND s.sector_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.transformation = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 40,
    "question": "\"Retrieve specific metric for a country over a period of time.\"\n\nThis generic question describes the query type without specific values, focusing on the key elements of the pattern: retrieving a metric for a country, over a period of time.",
    "ground_truth_sql": "SELECT g.year, g.value AS imports\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'India'\nAND i.indicator_name = 'Imports Merchandise'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show imports merchandise for India from 2010 to 2020",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS imports\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 41,
    "question": "\"Retrieve specific metric for a set of countries in a given year\"\n\nThis generic question captures the essence of the original query, focusing on the retrieval of a specific metric (e.g., tax revenue) for a set of countries (e.g., all countries with data) in a particular year (e.g., 2020). \n\nThe use of placeholders like [metric], [country], and [year] allows for a flexible and general description of the query type, applicable to various scenarios and datasets.",
    "ground_truth_sql": "SELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\nAND g.year = 2020\nORDER BY c.country_name",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "List all countries with tax revenue data for 2020",
    "sql_skeleton": "SELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\nAND g.[YEAR] = [NUMBER]\nORDER BY c.country_name",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 42,
    "question": "\"Identify top ranked [dimension] by [metric]\"\n\nExplanation:\n- [dimension] is equivalent to [country], [year], etc. in this context, representing the grouping or ranking criteria.\n- [metric] is equivalent to [metric], [obs_count], etc. in this context, representing the value being measured or ranked.\n\nApplying this pattern to the original SQL query, the generic question would be:\n\n\"Identify top ranked countries by number of [metric] observations\"",
    "ground_truth_sql": "SELECT c.country_name, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY obs_count DESC\nLIMIT 5",
    "difficulty": "medium",
    "category": "join_aggregation_limit",
    "original_question": "List the top 5 countries by number of GEM observations",
    "sql_skeleton": "SELECT c.country_name, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nGROUP BY c.country_name\nORDER BY obs_count DESC\nLIMIT [NUMBER]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 43,
    "question": "\"Retrieve specific metric for a country over a given time period\"\n\nThis question describes the query type without specifying the metric, country, or time period, but still conveys the essence of the query. It's a retrieval query that fetches a specific metric for a country within a specified time frame.",
    "ground_truth_sql": "SELECT g.year, g.value AS cpi_yoy\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Japan'\nAND i.indicator_name = 'CPI Price'\nAND i.unit = '% y-o-y, nominal'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show the CPI Price (% y-o-y) for Japan from 2015 to 2023",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS cpi_yoy\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND i.unit = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 44,
    "question": "\"Calculate the average of a specific metric across all countries in a given year, grouped by a particular dimension, using data from a specified table.\"\n\nThis generic question captures the essence of the original SQL query, describing the type of query without referencing specific values. It highlights the key elements of the query:\n\n- Calculation of average\n- Specific metric\n- All countries\n- Given year\n- Grouping by dimension\n- Data from a specified table",
    "ground_truth_sql": "SELECT AVG(g.value) AS avg_expenditure_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = 'General government'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year = 2019",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "What is the average expenditure (percent of GDP) for general government across all countries in 2019?",
    "sql_skeleton": "SELECT AVG(g.[METRIC]) AS avg_expenditure_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.transformation = [STRING]\nAND g.[YEAR] = [NUMBER]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 45,
    "question": "\"Show specific metric for a country over a range of years\"",
    "ground_truth_sql": "SELECT g.year, g.value AS stock_market\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'United Kingdom'\nAND i.indicator_name = 'Stock Markets'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show the stock market index for the United Kingdom from 2015 to 2023",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS stock_market\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 46,
    "question": "\"Retrieve specific metric for a country across a range of years\"\n\nThis question captures the essence of the SQL query type without specifying the exact values. It describes the query as retrieving a specific metric for a single country across multiple years, which is in line with the SQL pattern provided.",
    "ground_truth_sql": "SELECT g.year, g.value AS exports_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND i.indicator_name = 'Exports Merchandise'\nAND i.unit LIKE '%current US$%'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show exports merchandise (current US$ millions) for Brazil from 2010 to 2020",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS exports_millions\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND i.unit LIKE [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 47,
    "question": "\"List countries that have data for both [metric] and [metric]\" \u2192 \"List countries with data for both [metric] and [metric]\"\n\nHere's a revised version:\n\"List countries that have data for both [metric1] and [metric2]\"\n\nThis question type describes a query that retrieves a list of unique countries that have data available for two specific metrics. The generic question doesn't specify the exact metrics or the tables, but it conveys the idea of combining data from multiple metrics to get a list of countries.",
    "ground_truth_sql": "SELECT DISTINCT c.country_name\nFROM countries c\nWHERE c.country_id IN (SELECT DISTINCT country_id FROM gfs_observations)\nAND c.country_id IN (SELECT DISTINCT country_id FROM gem_observations)\nORDER BY c.country_name",
    "difficulty": "medium",
    "category": "subquery",
    "original_question": "List all countries that have data for both GFS and GEM",
    "sql_skeleton": "SELECT DISTINCT c.country_name\nFROM countries c\nWHERE c.[ID] IN (SELECT DISTINCT [ID] FROM gfs_observations)\nAND c.[ID] IN (SELECT DISTINCT [ID] FROM gem_observations)\nORDER BY c.country_name",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 48,
    "question": "\"Show the metric for a specific country over time\"\n\nThis generic question describes the query type as selecting a specific metric for a country, with the metric being shown over multiple years, rather than a single point in time.",
    "ground_truth_sql": "SELECT g.year, g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Germany'\nAND i.indicator_name = 'Unemployment Rate'\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show the unemployment rate for Germany for all available years",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 49,
    "question": "\"Retrieve countries where a specific metric exceeded a threshold value in any year within a given time period.\"\n\nThis generic question describes the query type without specific values, and can be used as a template to identify the query pattern in various scenarios.",
    "ground_truth_sql": "SELECT DISTINCT\n    c.country_name,\n    g.year,\n    g.value AS cpi_yoy_pct\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'CPI Price'\n    AND i.unit = '% y-o-y, nominal'\n    AND g.year BETWEEN 2015 AND 2023\n    AND g.value > 10\nORDER BY g.value DESC",
    "difficulty": "medium",
    "category": "filtering",
    "original_question": "Using GEM CPI data, find countries where inflation (CPI % year-over-year) exceeded 10% in any year between 2015 and 2023",
    "sql_skeleton": "SELECT DISTINCT\n    c.country_name,\n    g.[YEAR],\n    g.[METRIC] AS cpi_yoy_pct\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\n    AND i.unit = [STRING]\n    AND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\n    AND g.[METRIC] > [NUMBER]\nORDER BY g.[METRIC] DESC",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 50,
    "question": "\"Retrieve aggregated metric for [country] grouped by [dimension] (e.g. year) within [table] data\"\n\nThis generic question describes the query type without specific values, focusing on the key elements of the original SQL pattern:\n\n- The query aggregates a metric (e.g. count of observations).\n- The metric is grouped by a dimension (e.g. country and year).\n- The data is retrieved from a specific table (e.g. gfs_observations).",
    "ground_truth_sql": "SELECT c.country_name, g.year, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE g.year = 2020\nGROUP BY c.country_name, g.year\nORDER BY obs_count DESC\nLIMIT 20",
    "difficulty": "medium",
    "category": "join_aggregation",
    "original_question": "Count GFS observations per country per year (limited to 2020)",
    "sql_skeleton": "SELECT c.country_name, g.[YEAR], COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nWHERE g.[YEAR] = [NUMBER]\nGROUP BY c.country_name, g.[YEAR]\nORDER BY obs_count DESC\nLIMIT [NUMBER]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 51,
    "question": "\"Aggregate metric across multiple [dimension] in [table]\"\n\nThis generic question captures the essence of the original SQL query, focusing on the \"aggregation\" aspect (COUNT, SUM, AVG, etc.) and the \"dimension\" (in this case, [YEAR]). It also mentions the table and the metric being aggregated.",
    "ground_truth_sql": "SELECT year, COUNT(DISTINCT country_id) AS country_count\nFROM gfs_observations\nGROUP BY year\nORDER BY year",
    "difficulty": "medium",
    "category": "aggregation",
    "original_question": "Count the number of countries with GFS data for each year",
    "sql_skeleton": "SELECT [YEAR], COUNT(DISTINCT [ID]) AS country_count\nFROM gfs_observations\nGROUP BY [YEAR]\nORDER BY [YEAR]",
    "pattern_type": "grouped_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 52,
    "question": "\"Retrieve aggregated metric values grouped by dimension\"\n\nThis generic question describes the kind of query the SQL pattern represents, without specifying the particular values (e.g., table, metric, transformation type).",
    "ground_truth_sql": "SELECT transformation, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY transformation\nORDER BY obs_count DESC",
    "difficulty": "medium",
    "category": "aggregation",
    "original_question": "Count GFS observations by transformation type",
    "sql_skeleton": "SELECT transformation, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY transformation\nORDER BY obs_count DESC",
    "pattern_type": "grouped_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 53,
    "question": "\"Calculate average of metric for countries across a range of years, and rank the top N countries\"",
    "ground_truth_sql": "SELECT\n    c.country_name,\n    AVG(g.value) AS avg_gdp_millions,\n    COUNT(*) AS years_of_data\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2015 AND 2020\nGROUP BY c.country_name\nORDER BY avg_gdp_millions DESC\nLIMIT 10",
    "difficulty": "medium",
    "category": "aggregation_ranking",
    "original_question": "Calculate average GDP at market prices (constant 2010 US$) by country for 2015-2020, and rank the top 10 countries",
    "sql_skeleton": "SELECT\n    c.country_name,\n    AVG(g.[METRIC]) AS avg_gdp_millions,\n    COUNT(*) AS years_of_data\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\n    AND i.unit = [STRING]\n    AND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nGROUP BY c.country_name\nORDER BY avg_gdp_millions DESC\nLIMIT [NUMBER]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 54,
    "question": "\"Retrieve specific metric for a country over a range of years\"",
    "ground_truth_sql": "SELECT g.year, g.value AS revenue_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show government revenue (percent of GDP) for Australia from 2010 to 2020",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS revenue_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND s.sector_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.transformation = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 55,
    "question": "\"Retrieve the total value of [metric] for [year] from [table]\"\n\nThis generic question describes the query type without specific values, focusing on the key elements of the pattern: the metric being calculated, the year, and the table being queried.",
    "ground_truth_sql": "SELECT SUM(value) AS total_value\nFROM gfs_observations\nWHERE year = 2020",
    "difficulty": "medium",
    "category": "aggregation",
    "original_question": "What is the sum of all GFS observation values for the year 2020?",
    "sql_skeleton": "SELECT SUM([METRIC]) AS total_value\nFROM gfs_observations\nWHERE [YEAR] = [NUMBER]",
    "pattern_type": "simple_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 56,
    "question": "\"Retrieve aggregated metric for a specific country over a range of years\"\n\nThis generic question captures the essence of the original query, focusing on the key aspects of retrieving an aggregated value (total reserves) for a specific country (China) over a range of years (2010-2020).",
    "ground_truth_sql": "SELECT g.year, g.value AS total_reserves\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'China'\nAND i.indicator_name = 'Total Reserves'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year",
    "difficulty": "medium",
    "category": "join_filter",
    "original_question": "Show the total reserves for China from 2010 to 2020",
    "sql_skeleton": "SELECT g.[YEAR], g.[METRIC] AS total_reserves\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_join",
    "augmentation_type": "skeleton"
  },
  {
    "id": 57,
    "question": "\"Calculate the statistical properties of a metric for a country over a period of time, filtering by a specific dimension\"\n\nThis generic question captures the essence of the SQL pattern, focusing on:\n\n- Calculating statistical properties (e.g., variance, standard deviation)\n- A metric (e.g., unemployment rate)\n- A country\n- A period of time (using year range)\n- Filtering by a specific dimension (e.g., indicator name)\n\nThis generic question should apply to various scenarios and queries that follow the same pattern.",
    "ground_truth_sql": "SELECT c.country_name, \n       AVG(g.value) AS avg_unemployment,\n       COUNT(*) AS data_points,\n       (SUM(g.value * g.value) / COUNT(*)) - (AVG(g.value) * AVG(g.value)) AS variance\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nAND g.year BETWEEN 2010 AND 2020\nGROUP BY c.country_name\nHAVING COUNT(*) >= 5\nORDER BY variance DESC\nLIMIT 10",
    "difficulty": "hard",
    "category": "statistical",
    "original_question": "Find countries with the highest volatility (standard deviation) in unemployment rate from 2010 to 2020",
    "sql_skeleton": "SELECT c.country_name, \n       AVG(g.[METRIC]) AS avg_unemployment,\n       COUNT(*) AS data_points,\n       (SUM(g.[METRIC] * g.[METRIC]) / COUNT(*)) - (AVG(g.[METRIC]) * AVG(g.[METRIC])) AS variance\nFROM gem_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nGROUP BY c.country_name\nHAVING COUNT(*) >= [NUMBER]\nORDER BY variance DESC\nLIMIT [NUMBER]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 58,
    "question": "\"Retrieve cumulative sum of metric over time for a specific country\"\n\nThis generic question describes the query type without specific values, highlighting the key elements of the SQL pattern:\n\n- Retrieving a cumulative sum implies an aggregation operation.\n- Using \"metric\" and \"over time\" suggests a temporal dimension.\n- \"For a specific country\" indicates a filter on a geographic dimension.\n- The query uses a Common Table Expression (CTE) to simplify the query, which is a common pattern for this type of aggregation.",
    "ground_truth_sql": "WITH yearly_tax AS (\n    SELECT g.year, g.value AS tax_revenue\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'Australia'\n    AND s.sector_name = 'General government'\n    AND i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\n    AND g.transformation = 'Percent of GDP'\n)\nSELECT year, tax_revenue,\n       SUM(tax_revenue) OVER (ORDER BY year) AS cumulative_tax\nFROM yearly_tax\nORDER BY year",
    "difficulty": "hard",
    "category": "window_function",
    "original_question": "Calculate the cumulative sum of tax revenue over years for Australia",
    "sql_skeleton": "WITH yearly_tax AS (\n    SELECT g.[YEAR], g.[METRIC] AS tax_revenue\n    FROM gfs_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = [STRING]\n    AND s.sector_name = [STRING]\n    AND i.indicator_name = [STRING]\n    AND g.transformation = [STRING]\n)\nSELECT [YEAR], tax_revenue,\n       SUM(tax_revenue) OVER (ORDER BY [YEAR]) AS cumulative_tax\nFROM yearly_tax\nORDER BY [YEAR]",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 59,
    "question": "\"Calculate the difference between metric values for specific sector(s) within a specified country across a range of years, using data from a given table containing observations.\"",
    "ground_truth_sql": "SELECT g.year,\n       SUM(CASE WHEN s.sector_name = 'Central government including social security' THEN g.value ELSE 0 END) AS central_govt,\n       SUM(CASE WHEN s.sector_name = 'Local Government' THEN g.value ELSE 0 END) AS local_govt,\n       SUM(CASE WHEN s.sector_name = 'Central government including social security' THEN g.value ELSE 0 END) -\n       SUM(CASE WHEN s.sector_name = 'Local Government' THEN g.value ELSE 0 END) AS difference\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2015 AND 2022\nGROUP BY g.year\nORDER BY g.year",
    "difficulty": "hard",
    "category": "cross_sector_comparison",
    "original_question": "Compare government expenditure between central and local government for Brazil over 2015-2022",
    "sql_skeleton": "SELECT g.[YEAR],\n       SUM(CASE WHEN s.sector_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS central_govt,\n       SUM(CASE WHEN s.sector_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS local_govt,\n       SUM(CASE WHEN s.sector_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) -\n       SUM(CASE WHEN s.sector_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS difference\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\nAND i.indicator_name = [STRING]\nAND g.transformation = [STRING]\nAND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\nGROUP BY g.[YEAR]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  },
  {
    "id": 60,
    "question": "\"Calculate the average rate of change in a specific metric over time, ranking countries by this rate of change, only showing the top N results\"",
    "ground_truth_sql": "WITH gdp_by_year AS (\n    SELECT c.country_name, g.year, g.value AS gdp\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2014 AND 2020\n),\ngrowth_rates AS (\n    SELECT country_name, year,\n           (gdp - LAG(gdp) OVER (PARTITION BY country_name ORDER BY year)) / \n           LAG(gdp) OVER (PARTITION BY country_name ORDER BY year) * 100 AS growth_rate\n    FROM gdp_by_year\n)\nSELECT country_name, AVG(growth_rate) AS avg_growth_rate,\n       RANK() OVER (ORDER BY AVG(growth_rate) DESC) AS rank\nFROM growth_rates\nWHERE growth_rate IS NOT NULL\nGROUP BY country_name\nORDER BY avg_growth_rate DESC\nLIMIT 15",
    "difficulty": "hard",
    "category": "window_function",
    "original_question": "Rank countries by their average GDP growth from 2015 to 2020, showing only the top 15",
    "sql_skeleton": "WITH gdp_by_year AS (\n    SELECT c.country_name, g.[YEAR], g.[METRIC] AS gdp\n    FROM gem_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE i.indicator_name = [STRING]\n    AND i.unit = [STRING]\n    AND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\n),\ngrowth_rates AS (\n    SELECT country_name, [YEAR],\n           (gdp - LAG(gdp) OVER (PARTITION BY country_name ORDER BY [YEAR])) / \n           LAG(gdp) OVER (PARTITION BY country_name ORDER BY [YEAR]) * [NUMBER] AS growth_rate\n    FROM gdp_by_year\n)\nSELECT country_name, AVG(growth_rate) AS avg_growth_rate,\n       RANK() OVER (ORDER BY AVG(growth_rate) DESC) AS rank\nFROM growth_rates\nWHERE growth_rate IS NOT NULL\nGROUP BY country_name\nORDER BY avg_growth_rate DESC\nLIMIT [NUMBER]",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 61,
    "question": "\"Retrieve top-ranking countries by the combined availability of multiple metrics (total occurrences)\"",
    "ground_truth_sql": "WITH combined AS (\n    SELECT country_id, 'GFS' AS source FROM gfs_observations\n    UNION ALL\n    SELECT country_id, 'GEM' AS source FROM gem_observations\n)\nSELECT c.country_name, \n       SUM(CASE WHEN source = 'GFS' THEN 1 ELSE 0 END) AS gfs_obs,\n       SUM(CASE WHEN source = 'GEM' THEN 1 ELSE 0 END) AS gem_obs,\n       COUNT(*) AS total_obs\nFROM combined\nJOIN countries c ON combined.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY total_obs DESC\nLIMIT 5",
    "difficulty": "hard",
    "category": "union_aggregation",
    "original_question": "Find the top 5 countries by combined GFS and GEM data availability (total observations)",
    "sql_skeleton": "WITH combined AS (\n    SELECT [ID], [STRING] AS source FROM gfs_observations\n    UNION ALL\n    SELECT [ID], [STRING] AS source FROM gem_observations\n)\nSELECT c.country_name, \n       SUM(CASE WHEN source = [STRING] THEN [NUMBER] ELSE [NUMBER] END) AS gfs_obs,\n       SUM(CASE WHEN source = [STRING] THEN [NUMBER] ELSE [NUMBER] END) AS gem_obs,\n       COUNT(*) AS total_obs\nFROM combined\nJOIN countries c ON combined.[ID] = c.[ID]\nGROUP BY c.country_name\nORDER BY total_obs DESC\nLIMIT [NUMBER]",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 62,
    "question": "Based on the SQL pattern provided, the generic question that describes the query type can be:\n\n\"Identify the year with the largest change in a specified metric for each country in a given set of countries.\"\n\nThis question captures the essence of the SQL query, which involves:\n\n- Identifying a specific metric (e.g., GDP)\n- Analyzing the change in that metric over time (using LAG function)\n- Partitioning the data by country\n- Ranking the years with the largest change in the metric for each country\n- Selecting the year with the largest change (i.e., the worst year) for each country.",
    "ground_truth_sql": "WITH gdp_changes AS (\n    SELECT c.country_name, g.year, g.value AS gdp,\n           g.value - LAG(g.value) OVER (PARTITION BY c.country_name ORDER BY g.year) AS gdp_change\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ('United States', 'China', 'Japan', 'Germany', 'United Kingdom')\n    AND i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2008 AND 2022\n),\nranked AS (\n    SELECT country_name, year, gdp_change,\n           ROW_NUMBER() OVER (PARTITION BY country_name ORDER BY gdp_change ASC) AS rn\n    FROM gdp_changes\n    WHERE gdp_change IS NOT NULL\n)\nSELECT country_name, year AS worst_year, gdp_change AS gdp_drop\nFROM ranked\nWHERE rn = 1\nORDER BY gdp_drop ASC",
    "difficulty": "hard",
    "category": "window_function",
    "original_question": "Identify the year with the largest GDP drop for each major economy (US, China, Japan, Germany, UK) between 2008 and 2022",
    "sql_skeleton": "WITH gdp_changes AS (\n    SELECT c.country_name, g.[YEAR], g.[METRIC] AS gdp,\n           g.[METRIC] - LAG(g.[METRIC]) OVER (PARTITION BY c.country_name ORDER BY g.[YEAR]) AS gdp_change\n    FROM gem_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ([STRING], [STRING], [STRING], [STRING], [STRING])\n    AND i.indicator_name = [STRING]\n    AND i.unit = [STRING]\n    AND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\n),\nranked AS (\n    SELECT country_name, [YEAR], gdp_change,\n           ROW_NUMBER() OVER (PARTITION BY country_name ORDER BY gdp_change ASC) AS rn\n    FROM gdp_changes\n    WHERE gdp_change IS NOT NULL\n)\nSELECT country_name, [YEAR] AS worst_year, gdp_change AS gdp_drop\nFROM ranked\nWHERE rn = [NUMBER]\nORDER BY gdp_drop ASC",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 63,
    "question": "\"Calculate the distribution of a specific metric ([metric]) across various countries ([country]) and display the individual values along with their deviation from the group average, ranking them from highest to lowest.\"\n\nThis generic question captures the essence of the query, which:\n\n1. Retrieves data for a specific metric ([metric]) from a table ([table]) that likely contains data from a source like GFS Observations.\n2. Focusing on a subset of countries ([country]) with good data coverage.\n3. Compares individual values (country-specific metric values) with the overall average metric value across the selected countries.\n4. Displays individual values, group average, and the deviation from the group average, ranked from highest to lowest ([metric]).",
    "ground_truth_sql": "WITH Tax_Revenue AS (\n    SELECT \n        c.country_name,\n        g.value AS tax_revenue_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ('Singapore', 'Australia', 'Israel', 'South Africa', 'Chile')\n        AND g.year = 2020\n        AND s.sector_name = 'General government'\n        AND i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n),\nAvg_Tax AS (\n    SELECT AVG(tax_revenue_pct_gdp) AS avg_tax_revenue\n    FROM Tax_Revenue\n)\nSELECT \n    t.country_name,\n    t.tax_revenue_pct_gdp,\n    a.avg_tax_revenue AS group_average,\n    (t.tax_revenue_pct_gdp - a.avg_tax_revenue) AS difference_from_avg\nFROM Tax_Revenue t\nCROSS JOIN Avg_Tax a\nORDER BY t.tax_revenue_pct_gdp DESC",
    "difficulty": "hard",
    "category": "cross_country_comparison",
    "original_question": "Compare tax revenues as a percentage of GDP across countries with good data coverage (Singapore, Australia, Israel, South Africa, Chile) for 2020, ranking them from highest to lowest",
    "sql_skeleton": "WITH Tax_Revenue AS (\n    SELECT \n        c.country_name,\n        g.[METRIC] AS tax_revenue_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ([STRING], [STRING], [STRING], [STRING], [STRING])\n        AND g.[YEAR] = [NUMBER]\n        AND s.sector_name = [STRING]\n        AND i.indicator_name = [STRING]\n        AND g.transformation = [STRING]\n),\nAvg_Tax AS (\n    SELECT AVG(tax_revenue_pct_gdp) AS avg_tax_revenue\n    FROM Tax_Revenue\n)\nSELECT \n    t.country_name,\n    t.tax_revenue_pct_gdp,\n    a.avg_tax_revenue AS group_average,\n    (t.tax_revenue_pct_gdp - a.avg_tax_revenue) AS difference_from_avg\nFROM Tax_Revenue t\nCROSS JOIN Avg_Tax a\nORDER BY t.tax_revenue_pct_gdp DESC",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 64,
    "question": "\"Calculate year-over-year change in metric for a given country, identifying years with deficit values\"\n\nThis generic question captures the essence of the original SQL query, focusing on the key aspects of:\n\n- Calculating year-over-year change\n- Focusing on a specific country\n- Identifying deficit values\n\nIt omits specific details such as the metric, sector, and year ranges, making it a general description of the query type.",
    "ground_truth_sql": "WITH Yearly_Values AS (\n    SELECT \n        g.year,\n        g.value AS current_value,\n        LAG(g.value) OVER (ORDER BY g.year) AS previous_value\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'Singapore'\n        AND s.sector_name = 'General government'\n        AND i.indicator_name = 'Net lending (+) / net borrowing (-), Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year BETWEEN 2015 AND 2022\n)\nSELECT \n    year,\n    current_value,\n    previous_value,\n    (current_value - previous_value) AS yoy_change,\n    CASE \n        WHEN current_value < 0 THEN 'Deficit'\n        ELSE 'Surplus'\n    END AS fiscal_status\nFROM Yearly_Values\nWHERE previous_value IS NOT NULL\nORDER BY year",
    "difficulty": "hard",
    "category": "temporal_analysis",
    "original_question": "Show the year-over-year change in net lending/borrowing for Singapore's general government from 2015 to 2022, identifying years with deficits (negative values)",
    "sql_skeleton": "WITH Yearly_Values AS (\n    SELECT \n        g.[YEAR],\n        g.[METRIC] AS current_value,\n        LAG(g.[METRIC]) OVER (ORDER BY g.[YEAR]) AS previous_value\n    FROM gfs_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = [STRING]\n        AND s.sector_name = [STRING]\n        AND i.indicator_name = [STRING]\n        AND g.transformation = [STRING]\n        AND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\n)\nSELECT \n    [YEAR],\n    current_value,\n    previous_value,\n    (current_value - previous_value) AS yoy_change,\n    CASE \n        WHEN current_value < [NUMBER] THEN [STRING]\n        ELSE [STRING]\n    END AS fiscal_status\nFROM Yearly_Values\nWHERE previous_value IS NOT NULL\nORDER BY [YEAR]",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 65,
    "question": "\"Calculate the correlation between two metrics for a given dimension across all entities for a specific year\"\n\nThis generic question describes the query type without specific values, focusing on the core elements of the SQL pattern:\n\n- Two metrics (e.g., revenue and expenditure)\n- A given dimension (e.g., country)\n- All entities (e.g., countries)\n- A specific year",
    "ground_truth_sql": "WITH paired_data AS (\n    SELECT c.country_name,\n           SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN g.value ELSE 0 END) AS revenue,\n           SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN g.value ELSE 0 END) AS expenditure\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND g.year = 2019\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN 1 ELSE 0 END) > 0\n),\nstats AS (\n    SELECT \n        COUNT(*) AS n,\n        SUM(revenue) AS sum_x,\n        SUM(expenditure) AS sum_y,\n        SUM(revenue * expenditure) AS sum_xy,\n        SUM(revenue * revenue) AS sum_xx,\n        SUM(expenditure * expenditure) AS sum_yy\n    FROM paired_data\n)\nSELECT \n    n AS sample_size,\n    (n * sum_xy - sum_x * sum_y) / \n    SQRT((n * sum_xx - sum_x * sum_x) * (n * sum_yy - sum_y * sum_y)) AS correlation\nFROM stats",
    "difficulty": "hard",
    "category": "statistical",
    "original_question": "Calculate the correlation between government revenue and expenditure across all countries for 2019",
    "sql_skeleton": "WITH paired_data AS (\n    SELECT c.country_name,\n           SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS [METRIC],\n           SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS [METRIC]\n    FROM gfs_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = [STRING]\n    AND g.transformation = [STRING]\n    AND g.[YEAR] = [NUMBER]\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\n       AND SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\n),\nstats AS (\n    SELECT \n        COUNT(*) AS n,\n        SUM([METRIC]) AS sum_x,\n        SUM([METRIC]) AS sum_y,\n        SUM([METRIC] * [METRIC]) AS sum_xy,\n        SUM([METRIC] * [METRIC]) AS sum_xx,\n        SUM([METRIC] * [METRIC]) AS sum_yy\n    FROM paired_data\n)\nSELECT \n    n AS sample_size,\n    (n * sum_xy - sum_x * sum_y) / \n    SQRT((n * sum_xx - sum_x * sum_x) * (n * sum_yy - sum_y * sum_y)) AS correlation\nFROM stats",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 66,
    "question": "\"Identify countries where change in [metric] from [year1] to [year2] exceeds [threshold] percentage points.\"\n\nThis question captures the essence of the original SQL query, which calculates the difference in a specific metric (expenditure as percent of GDP) between two years (2019 and 2021) for countries where the change exceeds a certain threshold (5 percentage points).",
    "ground_truth_sql": "WITH Expenditure_By_Year AS (\n    SELECT \n        c.country_name,\n        SUM(CASE WHEN g.year = 2019 THEN g.value ELSE 0 END) AS exp_2019,\n        SUM(CASE WHEN g.year = 2021 THEN g.value ELSE 0 END) AS exp_2021\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n        AND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year IN (2019, 2021)\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN g.year = 2019 THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN g.year = 2021 THEN 1 ELSE 0 END) > 0\n)\nSELECT \n    country_name,\n    exp_2019,\n    exp_2021,\n    (exp_2021 - exp_2019) AS change_pct_points\nFROM Expenditure_By_Year\nWHERE (exp_2021 - exp_2019) > 5\nORDER BY (exp_2021 - exp_2019) DESC",
    "difficulty": "hard",
    "category": "change_detection",
    "original_question": "Identify countries where total expenditure as percent of GDP for general government increased by more than 5 percentage points between 2019 and 2021",
    "sql_skeleton": "WITH Expenditure_By_Year AS (\n    SELECT \n        c.country_name,\n        SUM(CASE WHEN g.[YEAR] = [NUMBER] THEN g.[METRIC] ELSE [NUMBER] END) AS exp_2019,\n        SUM(CASE WHEN g.[YEAR] = [NUMBER] THEN g.[METRIC] ELSE [NUMBER] END) AS exp_2021\n    FROM gfs_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = [STRING]\n        AND i.indicator_name = [STRING]\n        AND g.transformation = [STRING]\n        AND g.[YEAR] IN ([NUMBER], [NUMBER])\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN g.[YEAR] = [NUMBER] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\n       AND SUM(CASE WHEN g.[YEAR] = [NUMBER] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\n)\nSELECT \n    country_name,\n    exp_2019,\n    exp_2021,\n    (exp_2021 - exp_2019) AS change_pct_points\nFROM Expenditure_By_Year\nWHERE (exp_2021 - exp_2019) > [NUMBER]\nORDER BY (exp_2021 - exp_2019) DESC",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 67,
    "question": "\"Given a set of historical observations for a specific metric across various time points, calculate the annualized growth rate between the earliest and latest observations for a given country.\"",
    "ground_truth_sql": "WITH gdp_endpoints AS (\n    SELECT \n        MAX(CASE WHEN year = 2010 THEN value END) AS gdp_2010,\n        MAX(CASE WHEN year = 2020 THEN value END) AS gdp_2020\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'India'\n    AND i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year IN (2010, 2020)\n)\nSELECT gdp_2010, gdp_2020,\n       (POWER(gdp_2020 / gdp_2010, 1.0/10) - 1) * 100 AS cagr_percent\nFROM gdp_endpoints\nWHERE gdp_2010 > 0 AND gdp_2020 > 0",
    "difficulty": "hard",
    "category": "financial_calculation",
    "original_question": "Calculate the compound annual growth rate (CAGR) of GDP for India from 2010 to 2020",
    "sql_skeleton": "WITH gdp_endpoints AS (\n    SELECT \n        MAX(CASE WHEN [YEAR] = [NUMBER] THEN [METRIC] END) AS gdp_2010,\n        MAX(CASE WHEN [YEAR] = [NUMBER] THEN [METRIC] END) AS gdp_2020\n    FROM gem_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = [STRING]\n    AND i.indicator_name = [STRING]\n    AND i.unit = [STRING]\n    AND g.[YEAR] IN ([NUMBER], [NUMBER])\n)\nSELECT gdp_2010, gdp_2020,\n       (POWER(gdp_2020 / gdp_2010, [NUMBER].[NUMBER]/[NUMBER]) - [NUMBER]) * [NUMBER] AS cagr_percent\nFROM gdp_endpoints\nWHERE gdp_2010 > [NUMBER] AND gdp_2020 > [NUMBER]",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 68,
    "question": "\"Identify countries with consistently higher metric values over a specified period of time, aggregating data from a large dataset of indicators and observations, and filter results to include only countries with surplus metric values in a minimum number of years across the specified period.\"",
    "ground_truth_sql": "WITH fiscal_balance AS (\n    SELECT c.country_name, g.year,\n           SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN g.value ELSE 0 END) AS revenue,\n           SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN g.value ELSE 0 END) AS expenditure\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND g.year BETWEEN 2015 AND 2020\n    GROUP BY c.country_name, g.year\n    HAVING SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN 1 ELSE 0 END) > 0\n)\nSELECT country_name, COUNT(*) AS years_with_data,\n       SUM(CASE WHEN revenue > expenditure THEN 1 ELSE 0 END) AS surplus_years\nFROM fiscal_balance\nGROUP BY country_name\nHAVING COUNT(*) >= 5 AND SUM(CASE WHEN revenue > expenditure THEN 1 ELSE 0 END) = COUNT(*)\nORDER BY country_name",
    "difficulty": "hard",
    "category": "complex_aggregation",
    "original_question": "Find countries where government revenue consistently exceeded expenditure (surplus) every year from 2015 to 2020",
    "sql_skeleton": "WITH fiscal_balance AS (\n    SELECT c.country_name, g.[YEAR],\n           SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS [METRIC],\n           SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS [METRIC]\n    FROM gfs_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = [STRING]\n    AND g.transformation = [STRING]\n    AND g.[YEAR] BETWEEN [NUMBER] AND [NUMBER]\n    GROUP BY c.country_name, g.[YEAR]\n    HAVING SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\n       AND SUM(CASE WHEN i.indicator_name LIKE [STRING] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\n)\nSELECT country_name, COUNT(*) AS years_with_data,\n       SUM(CASE WHEN [METRIC] > [METRIC] THEN [NUMBER] ELSE [NUMBER] END) AS surplus_years\nFROM fiscal_balance\nGROUP BY country_name\nHAVING COUNT(*) >= [NUMBER] AND SUM(CASE WHEN [METRIC] > [METRIC] THEN [NUMBER] ELSE [NUMBER] END) = COUNT(*)\nORDER BY country_name",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 69,
    "question": "\"Find the country with the largest deterioration in a metric from one year to the next\"\n\nThis query is a type of \"Temporal Comparison\" or \"Time Series Analysis\" where the goal is to identify the greatest change in a metric across two consecutive years for a specific group (country). \n\nAlternatively, a more generic version could be:\n\"Identify the entity with the maximum absolute change in a metric between two consecutive years\"",
    "ground_truth_sql": "WITH balance AS (\n    SELECT\n        c.country_name,\n        g.year,\n        g.value AS net_lending_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n        AND i.indicator_name = 'Net lending (+) / net borrowing (-), Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year IN (2019, 2020)\n),\npaired AS (\n    SELECT\n        b2019.country_name,\n        b2019.net_lending_pct_gdp AS value_2019,\n        b2020.net_lending_pct_gdp AS value_2020,\n        (b2020.net_lending_pct_gdp - b2019.net_lending_pct_gdp) AS change_2020_minus_2019\n    FROM balance b2019\n    JOIN balance b2020\n      ON b2019.country_name = b2020.country_name\n     AND b2019.year = 2019\n     AND b2020.year = 2020\n)\nSELECT\n    country_name,\n    value_2019,\n    value_2020,\n    change_2020_minus_2019\nFROM paired\nORDER BY change_2020_minus_2019 ASC\nLIMIT 1",
    "difficulty": "hard",
    "category": "temporal_analysis",
    "original_question": "Find the country with the largest deterioration in net lending/borrowing (as percent of GDP) during 2019-2020",
    "sql_skeleton": "WITH balance AS (\n    SELECT\n        c.country_name,\n        g.[YEAR],\n        g.[METRIC] AS net_lending_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.[ID] = c.[ID]\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = [STRING]\n        AND i.indicator_name = [STRING]\n        AND g.transformation = [STRING]\n        AND g.[YEAR] IN ([NUMBER], [NUMBER])\n),\npaired AS (\n    SELECT\n        b2019.country_name,\n        b2019.net_lending_pct_gdp AS value_2019,\n        b2020.net_lending_pct_gdp AS value_2020,\n        (b2020.net_lending_pct_gdp - b2019.net_lending_pct_gdp) AS change_2020_minus_2019\n    FROM balance b2019\n    JOIN balance b2020\n      ON b2019.country_name = b2020.country_name\n     AND b2019.[YEAR] = [NUMBER]\n     AND b2020.[YEAR] = [NUMBER]\n)\nSELECT\n    country_name,\n    value_2019,\n    value_2020,\n    change_2020_minus_2019\nFROM paired\nORDER BY change_2020_minus_2019 ASC\nLIMIT [NUMBER]",
    "pattern_type": "nested_query",
    "augmentation_type": "skeleton"
  },
  {
    "id": 70,
    "question": "\"Retrieve aggregate values of a specific metric across all available years for a given country, showing the difference between two related metrics and the fiscal balance between them.\"",
    "ground_truth_sql": "SELECT\n    g.year,\n    SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS revenue_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS expenditure_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) -\n    SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS fiscal_balance\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\n    AND s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND i.indicator_name IN ('Revenue, Transactions (cash basis of recording), Cash basis', \n                             'Expenditure, Transactions (cash basis of recording), Cash basis')\nGROUP BY g.year\nHAVING SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN 1 ELSE 0 END) > 0\n   AND SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN 1 ELSE 0 END) > 0\nORDER BY g.year",
    "difficulty": "hard",
    "category": "cross_indicator_comparison",
    "original_question": "Compare government revenue and expenditure as percent of GDP for Australia across all available years, showing the fiscal balance (revenue minus expenditure)",
    "sql_skeleton": "SELECT\n    g.[YEAR],\n    SUM(CASE WHEN i.indicator_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS revenue_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS expenditure_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) -\n    SUM(CASE WHEN i.indicator_name = [STRING] THEN g.[METRIC] ELSE [NUMBER] END) AS fiscal_balance\nFROM gfs_observations g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = [STRING]\n    AND s.sector_name = [STRING]\n    AND g.transformation = [STRING]\n    AND i.indicator_name IN ([STRING], \n                             [STRING])\nGROUP BY g.[YEAR]\nHAVING SUM(CASE WHEN i.indicator_name = [STRING] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\n   AND SUM(CASE WHEN i.indicator_name = [STRING] THEN [NUMBER] ELSE [NUMBER] END) > [NUMBER]\nORDER BY g.[YEAR]",
    "pattern_type": "multi_table_aggregation",
    "augmentation_type": "skeleton"
  }
]