{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the average or total of [metric] grouped by [dimension] in the [table]\"\n\nThis generic question describes the query type as calculating a metric, grouping it by a specific dimension, and utilizing a particular table.\n\nPattern Type: sorted_retrieval\nInstructions: This query follows a sorted_retrieval pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT sector_id, sector_name FROM sectors ORDER BY sector_id\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific attribute from a set of [table] records where the attribute contains [STRING]\"\n\nPattern Type: simple_select\nInstructions: This query follows a simple_select pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT country_name FROM countries WHERE country_name LIKE '%United%'\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve count of specific metric for [dimension] with specific characteristic\"\n\nThis generic question describes the query type without specific values, focusing on the structure and purpose of the query rather than the exact details. \n\nThe placeholders used are:\n\n- [dimension] for the table or category being queried (e.g., 'indicators', 'sectors')\n- [metric] for the specific value being counted or calculated (e.g., 'count', 'GDP')\n- [characteristic] for the specific attribute or condition being applied (e.g., 'source', 'sector')\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS gfs_indicator_count FROM indicators WHERE source = 'GFS'\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric from [table] where [dimension] matches [string]\"\n\nPattern Type: simple_select\nInstructions: This query follows a simple_select pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT indicator_name FROM indicators WHERE source = 'GFS' AND indicator_name LIKE '%Revenue%'\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: Retrieve specific attribute from a table where attribute matches a given condition.\n\nPattern Type: sorted_retrieval\nInstructions: This query follows a sorted_retrieval pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT country_name FROM countries WHERE country_name LIKE 'A%' ORDER BY country_name\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate aggregate of [metric] across [dimension]\"\n\nThis generic question describes the query type without specific values, focusing on the core idea of the query: calculating an aggregate (in this case, a count) of a metric (observation_count) across a dimension (the table name, gem_observations).\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS observation_count FROM gem_observations\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve the total count of records in a specific [table]\"\n\nThis generic question describes the query type without using specific values, focusing on the action being performed (retrieving a count) and the key elements involved (a specific table).\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS observation_count FROM gfs_observations\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve distinct values of [metric] from [table] where [filter] is true, ordered by [metric]\"\n\nThis generic question describes the SQL pattern without specific values, focusing on the essential elements of the query:\n\n- [metric]: The attribute being retrieved (in this case, indicator_name).\n- [table]: The table containing the data (indicators).\n- [filter]: The condition applied to the data (source = [STRING]).\n- ordered by [metric]: The attribute used for sorting the results.\n\nPattern Type: sorted_retrieval\nInstructions: This query follows a sorted_retrieval pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT indicator_name FROM indicators WHERE source = 'GEM' ORDER BY indicator_name\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve the total count of unique [metric] in the [table] that match a specific [dimension] or criterion.\"\n\nThis generic question describes the type of query that the provided SQL pattern represents, without specifying any particular values. The placeholders are designed to be general and applicable to various query scenarios.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS gem_indicator_count FROM indicators WHERE source = 'GEM'\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve earliest [metric] for a given [table]\"\n\nThis generic question describes the query type, which is to retrieve the minimum or earliest value of a metric from a table. It does not specify the actual metric, table, or any other values, making it a generic pattern. \n\nThis pattern can be applied to various other queries, such as:\n\n- \"Retrieve latest [metric] for a given [table]\"\n- \"Calculate average of [metric] grouped by [dimension]\" \n- \"Compare [metric] between two [tables]\"\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT MIN(year) AS earliest_year FROM gfs_observations\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate total count of [metric] in [table]\"\n\nThis generic question describes the query type without specific values, using placeholders for the metric and table.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS indicator_count FROM indicators\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the count of distinct [dimension] from [table].\"\n\nThis generic question describes the query type without specific values, using placeholders for the key components of the query.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(DISTINCT country_id) AS country_count FROM gem_observations\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Find the minimum value of a metric aggregated across all observations in a table\"\n\nThis generic question captures the essence of the original query, which is to find the minimum value of a specific metric ([METRIC]) in a table ([table]) while excluding null values.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT MIN(value) AS min_value FROM gem_observations WHERE value IS NOT NULL\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve count of observations with specific transformation type\"\n\nThis generic question captures the essence of the original SQL query, focusing on the act of retrieving a count of observations based on a specific characteristic (in this case, the transformation type).\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS count FROM gfs_observations WHERE transformation = 'Percent of GDP'\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve the maximum value of [metric] from [table]\"\n\nThis generic question describes the query type, which is to retrieve the maximum value of a metric from a specific table, without specifying the particular metric, table, or values.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT MAX(year) AS latest_year FROM gem_observations\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve distinct values of [metric] from [table] where [dimension] matches [value pattern] and [filter dimension] equals [string value]\"\n\nThis generic question captures the essence of the original query, replacing specific values with placeholders. \n\nAlternatively, you could phrase it as:\n\n\"Extract unique [metric] names from [table] where [dimension] contains [string pattern] and [filter dimension] is [string value]\".\n\nBoth versions describe the query type without referencing specific values, making it a generic question that can be applied to various SQL queries with similar patterns.\n\nPattern Type: simple_select\nInstructions: This query follows a simple_select pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT indicator_name FROM indicators WHERE source = 'GFS' AND indicator_name LIKE '%Expense%'\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate [metric] count for [dimension] in [table]\"\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS country_count FROM countries\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric from a table\"\n\nThis generic question describes the query type without specifying any values, using placeholders that can be filled in to represent the actual query.\n\nPattern Type: simple_select\nInstructions: This query follows a simple_select pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT country_id, country_name FROM countries WHERE country_name = 'Brazil'\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve count of metric from table for given year\"\n\nThis generic question describes the query type, using placeholders like [metric], [table], and [year], without specific values.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS obs_count FROM gem_observations WHERE year = 2020\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve distinct values of a dimension from a given table\"\n\nThis generic question describes the query type as a simple retrieval of unique values from a table, without specifying the actual metric, table, or dimension used in the original SQL pattern.\n\nPattern Type: sorted_retrieval\nInstructions: This query follows a sorted_retrieval pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT sector_name FROM sectors ORDER BY sector_name\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve count of observations for a given year\"\n\nThis generic question describes the query type as a COUNT operation on a specific table (gfs_observations) filtered by a specific year, without referencing specific values.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT COUNT(*) AS obs_count FROM gfs_observations WHERE year = 2020\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve distinct countries where specific [metric] data is available for [year]\"\n\nThis generic question describes the type of query as retrieving distinct countries based on the availability of specific data for a given year.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE g.year = 2023\nORDER BY c.country_name\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve years where a specific country has data for a particular metric within a certain sector.\"\n\nThis generic question describes the query type without specific values, matching the SQL pattern:\n\nSELECT DISTINCT g.[YEAR]\nFROM [table] g\nJOIN countries c ON g.[ID] = c.[ID]\nJOIN sectors s ON g.[sector_id] = s.[sector_id]\nWHERE c.[country_name] = [STRING]\nAND s.[sector_name] = [STRING]\nORDER BY g.[YEAR]\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT g.year\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE c.country_name = 'France'\nAND s.sector_name = 'General government'\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric for given country over a specified time period\"\n\nThis generic question captures the essence of the query, which involves retrieving a specific metric (e.g., expenditure as a percentage of GDP) for a given country (Brazil) over a specified time period (2015 to 2022).\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS expenditure_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2015 AND 2022\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the average of a specific metric across all countries, grouped by the sector dimension.\"\n\nThis generic question captures the essence of the SQL query without specifying any concrete values, focusing on the type of operation (average calculation) and the dimension of grouping (sector). It uses placeholders like \"[metric]\" and \"[dimension]\" to convey the idea of a generic query.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT AVG(g.value) AS avg_revenue_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = 'General government'\nAND i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year = 2020\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the total count of [metric] per [dimension]\".\n\nThis generic question captures the essence of the SQL query, which is to count the occurrences of a particular [metric] grouped by a specific [dimension]. The placeholders [metric] and [dimension] can be replaced with actual values to create specific queries.\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT i.indicator_name, i.unit, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nGROUP BY i.indicator_name, i.unit\nORDER BY obs_count DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve total count of [metric] by [dimension]\"\n\nThis generic question describes the query type without specific values, indicating that it's a type of aggregation query (COUNT) that groups data by a specific dimension (scale) and retrieves the total count.\n\nPattern Type: grouped_aggregation\nInstructions: This query follows a grouped_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT scale, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY scale\nORDER BY obs_count DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Count the number of unique [country] that have [metric] data available for each [year]\"\n\nThis generic question captures the essence of the original query, which is to count the number of countries with a specific metric (unemployment rate) for each year, without specifying the actual values.\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, COUNT(DISTINCT g.country_id) AS country_count\nFROM gem_observations g\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nGROUP BY g.year\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: Generic Question: \"Count the number of unique [country] in [table] for each [year]\"\n\nThis generic question captures the essence of the original query, focusing on the query type (counting unique countries) rather than the specific values (e.g., \"GEM data\" and specific years).\n\nPattern Type: grouped_aggregation\nInstructions: This query follows a grouped_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT year, COUNT(DISTINCT country_id) AS country_count\nFROM gem_observations\nGROUP BY year\nORDER BY year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve the top [number] countries with the highest [metric] in [year]\"\n\nThis generic question captures the essence of the original SQL query, which is to retrieve a specific number of countries with the highest value of a particular metric in a given year.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT c.country_name, g.value AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'GDP at market prices'\nAND i.unit = 'constant 2010 US$, millions'\nAND g.year = 2019\nORDER BY g.value DESC\nLIMIT 10\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the average value of a metric across a specific dimension grouped by a set of categories.\"\n\nThis generic question captures the essence of the SQL query pattern provided, without referencing specific tables, columns, or values.\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT s.sector_name, AVG(g.value) AS avg_value\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nWHERE g.year = 2020\nGROUP BY s.sector_name\nORDER BY avg_value DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve aggregated metric for single country, grouped by [dimension], over a range of [year]\"\n\nThis generic question captures the essence of the original SQL query, replacing specific values with placeholders:\n\n- [metric] is replaced by \"aggregated metric\" since the query counts observations.\n- [country] is explicitly mentioned as a single country.\n- [dimension] is replaced by \"[year]\" since the query groups by year.\n- [year] is replaced by \"a range of [year]\" to indicate that the query considers multiple years.\n\nThis generic question can be applied to various SQL queries that follow a similar pattern, making it a useful template for understanding the type of query being executed.\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE c.country_name = 'United States'\nGROUP BY g.year\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve a specific metric for a country over a range of years\"\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS terms_of_trade\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\nAND i.indicator_name = 'Terms of Trade'\nAND g.year BETWEEN 2010 AND 2023\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve historical data for a specific [metric] in [country] within a specified [year] range\"\n\nThis generic question captures the essence of the original query, which involves retrieving data for a particular metric (exchange rate) in a specific country (Mexico) over a certain time period (2015-2023). By using placeholders like [metric], [country], and [year], the question can be applied to various scenarios involving different metrics, countries, and time ranges.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS exchange_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Mexico'\nAND i.indicator_name = 'Exchange rate'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve and summarize [metric] by [dimension], grouped by [grouping_dimension], and ordered by the [order_by_metric] for [entity] in [table].\"\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT c.country_name, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY obs_count DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve the maximum value of a specific metric for a country across different years.\"\n\nThis generic question describes the query type without specific values, focusing on the core characteristics of the original SQL pattern.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT c.country_name, g.year, g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nORDER BY g.value DESC\nLIMIT 1\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Show metric for a specific country across all available years\"\n\nThis generic question describes the query type without specific values, using placeholders like [metric], [country], and [year].\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS gdp_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'United States'\nAND i.indicator_name = 'GDP at market prices'\nAND i.unit = 'constant 2010 US$, millions'\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve country-year pairs with high [metric] value (> [threshold]) from [table] data between [start_year] and [end_year]\"\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT\n    c.country_name,\n    g.year,\n    g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\n    AND g.year BETWEEN 2010 AND 2020\n    AND g.value > 10\nORDER BY g.value DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric for a country over a range of years, filtered by sector and indicator type.\"\n\nThis generic question captures the essence of the original SQL query, abstracting away the specific details like the country, metric, and years, while still conveying the main intent of the query.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS social_benefits_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Germany'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Social benefits, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2000 AND 2020\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric for a country over a period of time.\"\n\nThis generic question describes the query type without specific values, focusing on the key elements of the pattern: retrieving a metric for a country, over a period of time.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS imports\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'India'\nAND i.indicator_name = 'Imports Merchandise'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric for a set of countries in a given year\"\n\nThis generic question captures the essence of the original query, focusing on the retrieval of a specific metric (e.g., tax revenue) for a set of countries (e.g., all countries with data) in a particular year (e.g., 2020). \n\nThe use of placeholders like [metric], [country], and [year] allows for a flexible and general description of the query type, applicable to various scenarios and datasets.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT c.country_name\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\nAND g.year = 2020\nORDER BY c.country_name\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Identify top ranked [dimension] by [metric]\"\n\nExplanation:\n- [dimension] is equivalent to [country], [year], etc. in this context, representing the grouping or ranking criteria.\n- [metric] is equivalent to [metric], [obs_count], etc. in this context, representing the value being measured or ranked.\n\nApplying this pattern to the original SQL query, the generic question would be:\n\n\"Identify top ranked countries by number of [metric] observations\"\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT c.country_name, COUNT(*) AS obs_count\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY obs_count DESC\nLIMIT 5\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric for a country over a given time period\"\n\nThis question describes the query type without specifying the metric, country, or time period, but still conveys the essence of the query. It's a retrieval query that fetches a specific metric for a country within a specified time frame.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS cpi_yoy\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Japan'\nAND i.indicator_name = 'CPI Price'\nAND i.unit = '% y-o-y, nominal'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the average of a specific metric across all countries in a given year, grouped by a particular dimension, using data from a specified table.\"\n\nThis generic question captures the essence of the original SQL query, describing the type of query without referencing specific values. It highlights the key elements of the query:\n\n- Calculation of average\n- Specific metric\n- All countries\n- Given year\n- Grouping by dimension\n- Data from a specified table\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT AVG(g.value) AS avg_expenditure_pct_gdp\nFROM gfs_observations g\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE s.sector_name = 'General government'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year = 2019\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Show specific metric for a country over a range of years\"\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS stock_market\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'United Kingdom'\nAND i.indicator_name = 'Stock Markets'\nAND g.year BETWEEN 2015 AND 2023\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric for a country across a range of years\"\n\nThis question captures the essence of the SQL query type without specifying the exact values. It describes the query as retrieving a specific metric for a single country across multiple years, which is in line with the SQL pattern provided.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS exports_millions\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND i.indicator_name = 'Exports Merchandise'\nAND i.unit LIKE '%current US$%'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"List countries that have data for both [metric] and [metric]\" \u2192 \"List countries with data for both [metric] and [metric]\"\n\nHere's a revised version:\n\"List countries that have data for both [metric1] and [metric2]\"\n\nThis question type describes a query that retrieves a list of unique countries that have data available for two specific metrics. The generic question doesn't specify the exact metrics or the tables, but it conveys the idea of combining data from multiple metrics to get a list of countries.\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT c.country_name\nFROM countries c\nWHERE c.country_id IN (SELECT DISTINCT country_id FROM gfs_observations)\nAND c.country_id IN (SELECT DISTINCT country_id FROM gem_observations)\nORDER BY c.country_name\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Show the metric for a specific country over time\"\n\nThis generic question describes the query type as selecting a specific metric for a country, with the metric being shown over multiple years, rather than a single point in time.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS unemployment_rate\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Germany'\nAND i.indicator_name = 'Unemployment Rate'\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve countries where a specific metric exceeded a threshold value in any year within a given time period.\"\n\nThis generic question describes the query type without specific values, and can be used as a template to identify the query pattern in various scenarios.\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT DISTINCT\n    c.country_name,\n    g.year,\n    g.value AS cpi_yoy_pct\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'CPI Price'\n    AND i.unit = '% y-o-y, nominal'\n    AND g.year BETWEEN 2015 AND 2023\n    AND g.value > 10\nORDER BY g.value DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve aggregated metric for [country] grouped by [dimension] (e.g. year) within [table] data\"\n\nThis generic question describes the query type without specific values, focusing on the key elements of the original SQL pattern:\n\n- The query aggregates a metric (e.g. count of observations).\n- The metric is grouped by a dimension (e.g. country and year).\n- The data is retrieved from a specific table (e.g. gfs_observations).\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT c.country_name, g.year, COUNT(*) AS obs_count\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nWHERE g.year = 2020\nGROUP BY c.country_name, g.year\nORDER BY obs_count DESC\nLIMIT 20\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Aggregate metric across multiple [dimension] in [table]\"\n\nThis generic question captures the essence of the original SQL query, focusing on the \"aggregation\" aspect (COUNT, SUM, AVG, etc.) and the \"dimension\" (in this case, [YEAR]). It also mentions the table and the metric being aggregated.\n\nPattern Type: grouped_aggregation\nInstructions: This query follows a grouped_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT year, COUNT(DISTINCT country_id) AS country_count\nFROM gfs_observations\nGROUP BY year\nORDER BY year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve aggregated metric values grouped by dimension\"\n\nThis generic question describes the kind of query the SQL pattern represents, without specifying the particular values (e.g., table, metric, transformation type).\n\nPattern Type: grouped_aggregation\nInstructions: This query follows a grouped_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT transformation, COUNT(*) AS obs_count\nFROM gfs_observations\nGROUP BY transformation\nORDER BY obs_count DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate average of metric for countries across a range of years, and rank the top N countries\"\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT\n    c.country_name,\n    AVG(g.value) AS avg_gdp_millions,\n    COUNT(*) AS years_of_data\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2015 AND 2020\nGROUP BY c.country_name\nORDER BY avg_gdp_millions DESC\nLIMIT 10\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve specific metric for a country over a range of years\"\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS revenue_pct_gdp\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\nAND s.sector_name = 'General government'\nAND i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve the total value of [metric] for [year] from [table]\"\n\nThis generic question describes the query type without specific values, focusing on the key elements of the pattern: the metric being calculated, the year, and the table being queried.\n\nPattern Type: simple_aggregation\nInstructions: This query follows a simple_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT SUM(value) AS total_value\nFROM gfs_observations\nWHERE year = 2020\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve aggregated metric for a specific country over a range of years\"\n\nThis generic question captures the essence of the original query, focusing on the key aspects of retrieving an aggregated value (total reserves) for a specific country (China) over a range of years (2010-2020).\n\nPattern Type: multi_table_join\nInstructions: This query follows a multi_table_join pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year, g.value AS total_reserves\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'China'\nAND i.indicator_name = 'Total Reserves'\nAND g.year BETWEEN 2010 AND 2020\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the statistical properties of a metric for a country over a period of time, filtering by a specific dimension\"\n\nThis generic question captures the essence of the SQL pattern, focusing on:\n\n- Calculating statistical properties (e.g., variance, standard deviation)\n- A metric (e.g., unemployment rate)\n- A country\n- A period of time (using year range)\n- Filtering by a specific dimension (e.g., indicator name)\n\nThis generic question should apply to various scenarios and queries that follow the same pattern.\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT c.country_name, \n       AVG(g.value) AS avg_unemployment,\n       COUNT(*) AS data_points,\n       (SUM(g.value * g.value) / COUNT(*)) - (AVG(g.value) * AVG(g.value)) AS variance\nFROM gem_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE i.indicator_name = 'Unemployment Rate'\nAND g.year BETWEEN 2010 AND 2020\nGROUP BY c.country_name\nHAVING COUNT(*) >= 5\nORDER BY variance DESC\nLIMIT 10\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve cumulative sum of metric over time for a specific country\"\n\nThis generic question describes the query type without specific values, highlighting the key elements of the SQL pattern:\n\n- Retrieving a cumulative sum implies an aggregation operation.\n- Using \"metric\" and \"over time\" suggests a temporal dimension.\n- \"For a specific country\" indicates a filter on a geographic dimension.\n- The query uses a Common Table Expression (CTE) to simplify the query, which is a common pattern for this type of aggregation.\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH yearly_tax AS (\n    SELECT g.year, g.value AS tax_revenue\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'Australia'\n    AND s.sector_name = 'General government'\n    AND i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\n    AND g.transformation = 'Percent of GDP'\n)\nSELECT year, tax_revenue,\n       SUM(tax_revenue) OVER (ORDER BY year) AS cumulative_tax\nFROM yearly_tax\nORDER BY year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the difference between metric values for specific sector(s) within a specified country across a range of years, using data from a given table containing observations.\"\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT g.year,\n       SUM(CASE WHEN s.sector_name = 'Central government including social security' THEN g.value ELSE 0 END) AS central_govt,\n       SUM(CASE WHEN s.sector_name = 'Local Government' THEN g.value ELSE 0 END) AS local_govt,\n       SUM(CASE WHEN s.sector_name = 'Central government including social security' THEN g.value ELSE 0 END) -\n       SUM(CASE WHEN s.sector_name = 'Local Government' THEN g.value ELSE 0 END) AS difference\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Brazil'\nAND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\nAND g.transformation = 'Percent of GDP'\nAND g.year BETWEEN 2015 AND 2022\nGROUP BY g.year\nORDER BY g.year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the average rate of change in a specific metric over time, ranking countries by this rate of change, only showing the top N results\"\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH gdp_by_year AS (\n    SELECT c.country_name, g.year, g.value AS gdp\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2014 AND 2020\n),\ngrowth_rates AS (\n    SELECT country_name, year,\n           (gdp - LAG(gdp) OVER (PARTITION BY country_name ORDER BY year)) / \n           LAG(gdp) OVER (PARTITION BY country_name ORDER BY year) * 100 AS growth_rate\n    FROM gdp_by_year\n)\nSELECT country_name, AVG(growth_rate) AS avg_growth_rate,\n       RANK() OVER (ORDER BY AVG(growth_rate) DESC) AS rank\nFROM growth_rates\nWHERE growth_rate IS NOT NULL\nGROUP BY country_name\nORDER BY avg_growth_rate DESC\nLIMIT 15\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve top-ranking countries by the combined availability of multiple metrics (total occurrences)\"\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH combined AS (\n    SELECT country_id, 'GFS' AS source FROM gfs_observations\n    UNION ALL\n    SELECT country_id, 'GEM' AS source FROM gem_observations\n)\nSELECT c.country_name, \n       SUM(CASE WHEN source = 'GFS' THEN 1 ELSE 0 END) AS gfs_obs,\n       SUM(CASE WHEN source = 'GEM' THEN 1 ELSE 0 END) AS gem_obs,\n       COUNT(*) AS total_obs\nFROM combined\nJOIN countries c ON combined.country_id = c.country_id\nGROUP BY c.country_name\nORDER BY total_obs DESC\nLIMIT 5\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: Based on the SQL pattern provided, the generic question that describes the query type can be:\n\n\"Identify the year with the largest change in a specified metric for each country in a given set of countries.\"\n\nThis question captures the essence of the SQL query, which involves:\n\n- Identifying a specific metric (e.g., GDP)\n- Analyzing the change in that metric over time (using LAG function)\n- Partitioning the data by country\n- Ranking the years with the largest change in the metric for each country\n- Selecting the year with the largest change (i.e., the worst year) for each country.\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH gdp_changes AS (\n    SELECT c.country_name, g.year, g.value AS gdp,\n           g.value - LAG(g.value) OVER (PARTITION BY c.country_name ORDER BY g.year) AS gdp_change\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ('United States', 'China', 'Japan', 'Germany', 'United Kingdom')\n    AND i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year BETWEEN 2008 AND 2022\n),\nranked AS (\n    SELECT country_name, year, gdp_change,\n           ROW_NUMBER() OVER (PARTITION BY country_name ORDER BY gdp_change ASC) AS rn\n    FROM gdp_changes\n    WHERE gdp_change IS NOT NULL\n)\nSELECT country_name, year AS worst_year, gdp_change AS gdp_drop\nFROM ranked\nWHERE rn = 1\nORDER BY gdp_drop ASC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the distribution of a specific metric ([metric]) across various countries ([country]) and display the individual values along with their deviation from the group average, ranking them from highest to lowest.\"\n\nThis generic question captures the essence of the query, which:\n\n1. Retrieves data for a specific metric ([metric]) from a table ([table]) that likely contains data from a source like GFS Observations.\n2. Focusing on a subset of countries ([country]) with good data coverage.\n3. Compares individual values (country-specific metric values) with the overall average metric value across the selected countries.\n4. Displays individual values, group average, and the deviation from the group average, ranked from highest to lowest ([metric]).\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH Tax_Revenue AS (\n    SELECT \n        c.country_name,\n        g.value AS tax_revenue_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name IN ('Singapore', 'Australia', 'Israel', 'South Africa', 'Chile')\n        AND g.year = 2020\n        AND s.sector_name = 'General government'\n        AND i.indicator_name = 'Taxes, Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n),\nAvg_Tax AS (\n    SELECT AVG(tax_revenue_pct_gdp) AS avg_tax_revenue\n    FROM Tax_Revenue\n)\nSELECT \n    t.country_name,\n    t.tax_revenue_pct_gdp,\n    a.avg_tax_revenue AS group_average,\n    (t.tax_revenue_pct_gdp - a.avg_tax_revenue) AS difference_from_avg\nFROM Tax_Revenue t\nCROSS JOIN Avg_Tax a\nORDER BY t.tax_revenue_pct_gdp DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate year-over-year change in metric for a given country, identifying years with deficit values\"\n\nThis generic question captures the essence of the original SQL query, focusing on the key aspects of:\n\n- Calculating year-over-year change\n- Focusing on a specific country\n- Identifying deficit values\n\nIt omits specific details such as the metric, sector, and year ranges, making it a general description of the query type.\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH Yearly_Values AS (\n    SELECT \n        g.year,\n        g.value AS current_value,\n        LAG(g.value) OVER (ORDER BY g.year) AS previous_value\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'Singapore'\n        AND s.sector_name = 'General government'\n        AND i.indicator_name = 'Net lending (+) / net borrowing (-), Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year BETWEEN 2015 AND 2022\n)\nSELECT \n    year,\n    current_value,\n    previous_value,\n    (current_value - previous_value) AS yoy_change,\n    CASE \n        WHEN current_value < 0 THEN 'Deficit'\n        ELSE 'Surplus'\n    END AS fiscal_status\nFROM Yearly_Values\nWHERE previous_value IS NOT NULL\nORDER BY year\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Calculate the correlation between two metrics for a given dimension across all entities for a specific year\"\n\nThis generic question describes the query type without specific values, focusing on the core elements of the SQL pattern:\n\n- Two metrics (e.g., revenue and expenditure)\n- A given dimension (e.g., country)\n- All entities (e.g., countries)\n- A specific year\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH paired_data AS (\n    SELECT c.country_name,\n           SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN g.value ELSE 0 END) AS revenue,\n           SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN g.value ELSE 0 END) AS expenditure\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND g.year = 2019\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN 1 ELSE 0 END) > 0\n),\nstats AS (\n    SELECT \n        COUNT(*) AS n,\n        SUM(revenue) AS sum_x,\n        SUM(expenditure) AS sum_y,\n        SUM(revenue * expenditure) AS sum_xy,\n        SUM(revenue * revenue) AS sum_xx,\n        SUM(expenditure * expenditure) AS sum_yy\n    FROM paired_data\n)\nSELECT \n    n AS sample_size,\n    (n * sum_xy - sum_x * sum_y) / \n    SQRT((n * sum_xx - sum_x * sum_x) * (n * sum_yy - sum_y * sum_y)) AS correlation\nFROM stats\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Identify countries where change in [metric] from [year1] to [year2] exceeds [threshold] percentage points.\"\n\nThis question captures the essence of the original SQL query, which calculates the difference in a specific metric (expenditure as percent of GDP) between two years (2019 and 2021) for countries where the change exceeds a certain threshold (5 percentage points).\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH Expenditure_By_Year AS (\n    SELECT \n        c.country_name,\n        SUM(CASE WHEN g.year = 2019 THEN g.value ELSE 0 END) AS exp_2019,\n        SUM(CASE WHEN g.year = 2021 THEN g.value ELSE 0 END) AS exp_2021\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n        AND i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year IN (2019, 2021)\n    GROUP BY c.country_name\n    HAVING SUM(CASE WHEN g.year = 2019 THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN g.year = 2021 THEN 1 ELSE 0 END) > 0\n)\nSELECT \n    country_name,\n    exp_2019,\n    exp_2021,\n    (exp_2021 - exp_2019) AS change_pct_points\nFROM Expenditure_By_Year\nWHERE (exp_2021 - exp_2019) > 5\nORDER BY (exp_2021 - exp_2019) DESC\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Given a set of historical observations for a specific metric across various time points, calculate the annualized growth rate between the earliest and latest observations for a given country.\"\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH gdp_endpoints AS (\n    SELECT \n        MAX(CASE WHEN year = 2010 THEN value END) AS gdp_2010,\n        MAX(CASE WHEN year = 2020 THEN value END) AS gdp_2020\n    FROM gem_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE c.country_name = 'India'\n    AND i.indicator_name = 'GDP at market prices'\n    AND i.unit = 'constant 2010 US$, millions'\n    AND g.year IN (2010, 2020)\n)\nSELECT gdp_2010, gdp_2020,\n       (POWER(gdp_2020 / gdp_2010, 1.0/10) - 1) * 100 AS cagr_percent\nFROM gdp_endpoints\nWHERE gdp_2010 > 0 AND gdp_2020 > 0\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Identify countries with consistently higher metric values over a specified period of time, aggregating data from a large dataset of indicators and observations, and filter results to include only countries with surplus metric values in a minimum number of years across the specified period.\"\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH fiscal_balance AS (\n    SELECT c.country_name, g.year,\n           SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN g.value ELSE 0 END) AS revenue,\n           SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN g.value ELSE 0 END) AS expenditure\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND g.year BETWEEN 2015 AND 2020\n    GROUP BY c.country_name, g.year\n    HAVING SUM(CASE WHEN i.indicator_name LIKE '%Revenue%' THEN 1 ELSE 0 END) > 0\n       AND SUM(CASE WHEN i.indicator_name LIKE '%Expenditure%' THEN 1 ELSE 0 END) > 0\n)\nSELECT country_name, COUNT(*) AS years_with_data,\n       SUM(CASE WHEN revenue > expenditure THEN 1 ELSE 0 END) AS surplus_years\nFROM fiscal_balance\nGROUP BY country_name\nHAVING COUNT(*) >= 5 AND SUM(CASE WHEN revenue > expenditure THEN 1 ELSE 0 END) = COUNT(*)\nORDER BY country_name\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Find the country with the largest deterioration in a metric from one year to the next\"\n\nThis query is a type of \"Temporal Comparison\" or \"Time Series Analysis\" where the goal is to identify the greatest change in a metric across two consecutive years for a specific group (country). \n\nAlternatively, a more generic version could be:\n\"Identify the entity with the maximum absolute change in a metric between two consecutive years\"\n\nPattern Type: nested_query\nInstructions: This query follows a nested_query pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nWITH balance AS (\n    SELECT\n        c.country_name,\n        g.year,\n        g.value AS net_lending_pct_gdp\n    FROM gfs_observations g\n    JOIN countries c ON g.country_id = c.country_id\n    JOIN sectors s ON g.sector_id = s.sector_id\n    JOIN indicators i ON g.indicator_id = i.indicator_id\n    WHERE s.sector_name = 'General government'\n        AND i.indicator_name = 'Net lending (+) / net borrowing (-), Transactions (cash basis of recording), Cash basis'\n        AND g.transformation = 'Percent of GDP'\n        AND g.year IN (2019, 2020)\n),\npaired AS (\n    SELECT\n        b2019.country_name,\n        b2019.net_lending_pct_gdp AS value_2019,\n        b2020.net_lending_pct_gdp AS value_2020,\n        (b2020.net_lending_pct_gdp - b2019.net_lending_pct_gdp) AS change_2020_minus_2019\n    FROM balance b2019\n    JOIN balance b2020\n      ON b2019.country_name = b2020.country_name\n     AND b2019.year = 2019\n     AND b2020.year = 2020\n)\nSELECT\n    country_name,\n    value_2019,\n    value_2020,\n    change_2020_minus_2019\nFROM paired\nORDER BY change_2020_minus_2019 ASC\nLIMIT 1\n```"}]}
{"messages": [{"role": "system", "content": "You are an expert SQL generator. Focus on recognizing query patterns and structures to generate accurate SQL."}, {"role": "user", "content": "Database Schema:\nTable: countries\nColumns:\n  - country_id (INTEGER)\n  - country_name (TEXT)\n  - region (TEXT)\n\nTable: sqlite_sequence\nColumns:\n  - name ()\n  - seq ()\n\nTable: time_periods\nColumns:\n  - year (INTEGER)\n\nTable: sectors\nColumns:\n  - sector_id (INTEGER)\n  - sector_name (TEXT)\n  - sector_description (TEXT)\n\nTable: indicators\nColumns:\n  - indicator_id (INTEGER)\n  - indicator_code (TEXT)\n  - indicator_name (TEXT)\n  - source (TEXT)\n  - unit (TEXT)\n  - description (TEXT)\n\nTable: gfs_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - sector_id (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - transformation (TEXT)\n  - scale (TEXT)\n  - frequency (TEXT)\n\nTable: gem_observations\nColumns:\n  - observation_id (INTEGER)\n  - country_id (INTEGER)\n  - year (INTEGER)\n  - indicator_id (INTEGER)\n  - value (REAL)\n  - seasonal_adjustment (BOOLEAN)\n\n\nQuestion: \"Retrieve aggregate values of a specific metric across all available years for a given country, showing the difference between two related metrics and the fiscal balance between them.\"\n\nPattern Type: multi_table_aggregation\nInstructions: This query follows a multi_table_aggregation pattern. Identify the required SQL components and generate accurate SQL."}, {"role": "assistant", "content": "```sql\nSELECT\n    g.year,\n    SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS revenue_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS expenditure_pct_gdp,\n    SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) -\n    SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN g.value ELSE 0 END) AS fiscal_balance\nFROM gfs_observations g\nJOIN countries c ON g.country_id = c.country_id\nJOIN sectors s ON g.sector_id = s.sector_id\nJOIN indicators i ON g.indicator_id = i.indicator_id\nWHERE c.country_name = 'Australia'\n    AND s.sector_name = 'General government'\n    AND g.transformation = 'Percent of GDP'\n    AND i.indicator_name IN ('Revenue, Transactions (cash basis of recording), Cash basis', \n                             'Expenditure, Transactions (cash basis of recording), Cash basis')\nGROUP BY g.year\nHAVING SUM(CASE WHEN i.indicator_name = 'Revenue, Transactions (cash basis of recording), Cash basis' THEN 1 ELSE 0 END) > 0\n   AND SUM(CASE WHEN i.indicator_name = 'Expenditure, Transactions (cash basis of recording), Cash basis' THEN 1 ELSE 0 END) > 0\nORDER BY g.year\n```"}]}
